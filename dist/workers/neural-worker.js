(()=>{"use strict";var t={d:(e,o)=>{for(var n in o)t.o(o,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:o[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{default:()=>n});const o=new class{constructor(){this.networks=new Map}initializeNetwork(t,e,o){const n=new Map,r=new Map,s=new Map;e.forEach((t=>{n.set(t.id,{...t}),s.set(t.id,0)})),o.forEach((t=>{r.has(t.from)||r.set(t.from,[]),r.get(t.from).push({...t})})),this.networks.set(t,{nodes:n,connections:r,activations:s})}propagateNetwork(t,e){const o=this.networks.get(t);if(!o)throw new Error(`Network ${t} not found`);Object.entries(e).forEach((([t,e])=>{o.nodes.has(t)&&o.activations.set(t,e)}));for(const[t,e]of o.nodes)"input"!==e.type&&o.activations.set(t,e.bias);for(const[t,e]of o.connections){const n=o.activations.get(t)||0;for(const t of e){if(!t.active)continue;const e=(o.activations.get(t.to)||0)+n*t.weight;o.activations.set(t.to,this.sigmoid(e))}}return Object.fromEntries(o.activations)}mutateNetwork(t,e){const o=this.networks.get(t);if(!o)throw new Error(`Network ${t} not found`);let n=!1;for(const t of o.connections.values())for(const o of t)Math.random()<e&&(o.weight+=.2*(Math.random()-.5),o.weight=Math.max(-2,Math.min(2,o.weight)),n=!0);for(const t of o.nodes.values())Math.random()<e&&(t.bias+=.1*(Math.random()-.5),t.bias=Math.max(-1,Math.min(1,t.bias)),n=!0);return n}calculateNeuralActivity(t){const e=this.networks.get(t);if(!e)throw new Error(`Network ${t} not found`);let o=0,n=0;for(const t of e.activations.values())o+=Math.abs(t),n++;const r=n>0?o/n:0;let s=0,a=0;for(const t of e.connections.values())for(const e of t)e.active&&(s+=Math.abs(e.weight),a++);return{activity:r,connectionStrength:a>0?s/a:0,nodeCount:n,connectionCount:a}}sigmoid(t){return t>10?1:t<-10?0:1/(1+Math.exp(-t))}cleanupNetwork(t){return this.networks.delete(t)}getWorkerStats(){let t=0,e=0;return this.networks.forEach((o=>{t+=o.nodes.size,e+=Array.from(o.connections.values()).reduce(((t,e)=>t+e.length),0)})),{networkCount:this.networks.size,memoryUsage:64*(t+e)}}};self.onmessage=t=>{const e=performance.now(),{type:n,id:r,payload:s}=t.data;try{let t;switch(n){case"NEURAL_INIT":o.initializeNetwork(s.networkId,s.nodes,s.connections),t={success:!0};break;case"NEURAL_PROPAGATE":t=o.propagateNetwork(s.networkId,s.inputs);break;case"NEURAL_MUTATE":t=o.mutateNetwork(s.networkId,s.rate);break;case"NEURAL_ACTIVITY":t=o.calculateNeuralActivity(s.networkId);break;default:throw new Error(`Unknown message type: ${n}`)}const a={type:"NEURAL_RESULT",id:r,payload:t,processingTime:performance.now()-e};self.postMessage(a)}catch(t){const o=performance.now()-e,n={type:"NEURAL_ERROR",id:r,payload:{message:t instanceof Error?t.message:String(t),stack:t instanceof Error?t.stack:void 0},processingTime:o};self.postMessage(n)}};const n=o;var r=self;for(var s in e)r[s]=e[s];e.__esModule&&Object.defineProperty(r,"__esModule",{value:!0})})();
//# sourceMappingURL=neural-worker.js.map