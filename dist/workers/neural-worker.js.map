{"version":3,"file":"neural-worker.js","mappings":"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","sources":["webpack://symbiont/webpack/bootstrap","webpack://symbiont/webpack/runtime/define property getters","webpack://symbiont/webpack/runtime/hasOwnProperty shorthand","webpack://symbiont/webpack/runtime/make namespace object","webpack://symbiont/./src/workers/NeuralWorker.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Web Worker pour les calculs neuraux intensifs\r\n// Évite de bloquer le thread principal du navigateur\r\n\r\nimport { NeuralNode, NeuralConnection } from '../core/interfaces/INeuralMesh';\r\n\r\nexport interface WorkerMessage {\r\n  type: 'NEURAL_PROPAGATE' | 'NEURAL_MUTATE' | 'NEURAL_ACTIVITY' | 'NEURAL_INIT';\r\n  id: string;\r\n  payload: any;\r\n}\r\n\r\nexport interface WorkerResponse {\r\n  type: 'NEURAL_RESULT' | 'NEURAL_ERROR';\r\n  id: string;\r\n  payload: any;\r\n  processingTime: number;\r\n}\r\n\r\nexport interface NeuralNetworkState {\r\n  nodes: Map<string, NeuralNode>;\r\n  connections: Map<string, NeuralConnection[]>;\r\n  activations: Map<string, number>;\r\n}\r\n\r\nclass NeuralWorkerEngine {\r\n  private networks: Map<string, NeuralNetworkState> = new Map();\r\n\r\n  /**\r\n   * Initialise un réseau neuronal dans le worker\r\n   */\r\n  initializeNetwork(networkId: string, nodes: NeuralNode[], connections: NeuralConnection[]): void {\r\n    const nodeMap = new Map<string, NeuralNode>();\r\n    const connectionMap = new Map<string, NeuralConnection[]>();\r\n    const activationMap = new Map<string, number>();\r\n\r\n    // Setup nodes\r\n    nodes.forEach(node => {\r\n      nodeMap.set(node.id, { ...node });\r\n      activationMap.set(node.id, 0);\r\n    });\r\n\r\n    // Setup connections\r\n    connections.forEach(conn => {\r\n      if (!connectionMap.has(conn.from)) {\r\n        connectionMap.set(conn.from, []);\r\n      }\r\n      connectionMap.get(conn.from)!.push({ ...conn });\r\n    });\r\n\r\n    this.networks.set(networkId, {\r\n      nodes: nodeMap,\r\n      connections: connectionMap,\r\n      activations: activationMap\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Propage les activations dans le réseau (opération intensive)\r\n   */\r\n  propagateNetwork(networkId: string, inputs: Record<string, number>): Record<string, number> {\r\n    const network = this.networks.get(networkId);\r\n    if (!network) {\r\n      throw new Error(`Network ${networkId} not found`);\r\n    }\r\n\r\n    // Set input activations\r\n    Object.entries(inputs).forEach(([nodeId, value]) => {\r\n      if (network.nodes.has(nodeId)) {\r\n        network.activations.set(nodeId, value);\r\n      }\r\n    });\r\n\r\n    // Reset non-input activations\r\n    for (const [nodeId, node] of network.nodes) {\r\n      if (node.type !== 'input') {\r\n        network.activations.set(nodeId, node.bias);\r\n      }\r\n    }\r\n\r\n    // Propagate through connections\r\n    for (const [fromId, connections] of network.connections) {\r\n      const fromActivation = network.activations.get(fromId) || 0;\r\n      \r\n      for (const connection of connections) {\r\n        if (!connection.active) continue;\r\n        \r\n        const currentActivation = network.activations.get(connection.to) || 0;\r\n        const newActivation = currentActivation + (fromActivation * connection.weight);\r\n        network.activations.set(connection.to, this.sigmoid(newActivation));\r\n      }\r\n    }\r\n\r\n    // Return all activations\r\n    return Object.fromEntries(network.activations);\r\n  }\r\n\r\n  /**\r\n   * Applique des mutations au réseau\r\n   */\r\n  mutateNetwork(networkId: string, rate: number): boolean {\r\n    const network = this.networks.get(networkId);\r\n    if (!network) {\r\n      throw new Error(`Network ${networkId} not found`);\r\n    }\r\n\r\n    let mutationApplied = false;\r\n\r\n    // Mutate connection weights\r\n    for (const connections of network.connections.values()) {\r\n      for (const connection of connections) {\r\n        if (Math.random() < rate) {\r\n          connection.weight += (Math.random() - 0.5) * 0.2;\r\n          connection.weight = Math.max(-2, Math.min(2, connection.weight));\r\n          mutationApplied = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Mutate node biases\r\n    for (const node of network.nodes.values()) {\r\n      if (Math.random() < rate) {\r\n        node.bias += (Math.random() - 0.5) * 0.1;\r\n        node.bias = Math.max(-1, Math.min(1, node.bias));\r\n        mutationApplied = true;\r\n      }\r\n    }\r\n\r\n    return mutationApplied;\r\n  }\r\n\r\n  /**\r\n   * Calcule les métriques d'activité neurale\r\n   */\r\n  calculateNeuralActivity(networkId: string): {\r\n    activity: number;\r\n    connectionStrength: number;\r\n    nodeCount: number;\r\n    connectionCount: number;\r\n  } {\r\n    const network = this.networks.get(networkId);\r\n    if (!network) {\r\n      throw new Error(`Network ${networkId} not found`);\r\n    }\r\n\r\n    // Neural activity\r\n    let totalActivity = 0;\r\n    let nodeCount = 0;\r\n    for (const activation of network.activations.values()) {\r\n      totalActivity += Math.abs(activation);\r\n      nodeCount++;\r\n    }\r\n    const activity = nodeCount > 0 ? totalActivity / nodeCount : 0;\r\n\r\n    // Connection strength\r\n    let totalWeight = 0;\r\n    let connectionCount = 0;\r\n    for (const connections of network.connections.values()) {\r\n      for (const connection of connections) {\r\n        if (connection.active) {\r\n          totalWeight += Math.abs(connection.weight);\r\n          connectionCount++;\r\n        }\r\n      }\r\n    }\r\n    const connectionStrength = connectionCount > 0 ? totalWeight / connectionCount : 0;\r\n\r\n    return {\r\n      activity,\r\n      connectionStrength,\r\n      nodeCount,\r\n      connectionCount\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Fonction d'activation sigmoïde optimisée\r\n   */\r\n  private sigmoid(x: number): number {\r\n    // Optimisation : clamp extreme values pour éviter overflow\r\n    if (x > 10) return 1;\r\n    if (x < -10) return 0;\r\n    return 1 / (1 + Math.exp(-x));\r\n  }\r\n\r\n  /**\r\n   * Nettoie un réseau de la mémoire\r\n   */\r\n  cleanupNetwork(networkId: string): boolean {\r\n    return this.networks.delete(networkId);\r\n  }\r\n\r\n  /**\r\n   * Retourne les stats du worker\r\n   */\r\n  getWorkerStats(): {\r\n    networkCount: number;\r\n    memoryUsage: number;\r\n  } {\r\n    let totalNodes = 0;\r\n    let totalConnections = 0;\r\n\r\n    this.networks.forEach(network => {\r\n      totalNodes += network.nodes.size;\r\n      totalConnections += Array.from(network.connections.values())\r\n        .reduce((sum, conns) => sum + conns.length, 0);\r\n    });\r\n\r\n    return {\r\n      networkCount: this.networks.size,\r\n      memoryUsage: (totalNodes + totalConnections) * 64 // bytes estimation\r\n    };\r\n  }\r\n}\r\n\r\n// Instance du moteur neural pour ce worker\r\nconst neuralEngine = new NeuralWorkerEngine();\r\n\r\n// Gestionnaire de messages du worker\r\nself.onmessage = (event: MessageEvent<WorkerMessage>) => {\r\n  const startTime = performance.now();\r\n  const { type, id, payload } = event.data;\r\n  \r\n  try {\r\n    let result: any;\r\n\r\n    switch (type) {\r\n      case 'NEURAL_INIT':\r\n        neuralEngine.initializeNetwork(\r\n          payload.networkId,\r\n          payload.nodes,\r\n          payload.connections\r\n        );\r\n        result = { success: true };\r\n        break;\r\n\r\n      case 'NEURAL_PROPAGATE':\r\n        result = neuralEngine.propagateNetwork(\r\n          payload.networkId,\r\n          payload.inputs\r\n        );\r\n        break;\r\n\r\n      case 'NEURAL_MUTATE':\r\n        result = neuralEngine.mutateNetwork(\r\n          payload.networkId,\r\n          payload.rate\r\n        );\r\n        break;\r\n\r\n      case 'NEURAL_ACTIVITY':\r\n        result = neuralEngine.calculateNeuralActivity(payload.networkId);\r\n        break;\r\n\r\n      default:\r\n        throw new Error(`Unknown message type: ${type}`);\r\n    }\r\n\r\n    const processingTime = performance.now() - startTime;\r\n\r\n    const response: WorkerResponse = {\r\n      type: 'NEURAL_RESULT',\r\n      id,\r\n      payload: result,\r\n      processingTime\r\n    };\r\n\r\n    self.postMessage(response);\r\n\r\n  } catch (error) {\r\n    const processingTime = performance.now() - startTime;\r\n    \r\n    const errorResponse: WorkerResponse = {\r\n      type: 'NEURAL_ERROR',\r\n      id,\r\n      payload: {\r\n        message: error instanceof Error ? error.message : String(error),\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      },\r\n      processingTime\r\n    };\r\n\r\n    self.postMessage(errorResponse);\r\n  }\r\n};\r\n\r\n// Export pour TypeScript (ne sera pas utilisé dans le contexte worker)\r\nexport default neuralEngine; "],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","neuralEngine","networks","Map","initializeNetwork","networkId","nodes","connections","nodeMap","connectionMap","activationMap","forEach","node","set","id","conn","has","from","push","this","activations","propagateNetwork","inputs","network","Error","entries","nodeId","type","bias","fromId","fromActivation","connection","active","newActivation","to","weight","sigmoid","fromEntries","mutateNetwork","rate","mutationApplied","values","Math","random","max","min","calculateNeuralActivity","totalActivity","nodeCount","activation","abs","activity","totalWeight","connectionCount","connectionStrength","x","exp","cleanupNetwork","delete","getWorkerStats","totalNodes","totalConnections","size","Array","reduce","sum","conns","length","networkCount","memoryUsage","self","onmessage","event","startTime","performance","now","payload","data","result","success","response","processingTime","postMessage","error","errorResponse","message","String","stack","undefined"],"sourceRoot":""}