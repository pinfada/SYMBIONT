"use strict";(self.webpackChunksymbiont=self.webpackChunksymbiont||[]).push([[638],{638:(e,t,r)=>{r.r(t),r.d(t,{WebGLOrganismViewer:()=>h,default:()=>d});var n=r(848),o=r(540),i=r(23),a=r(513);const s=class{static createShader(e,t,r){const n=e.createShader(t);if(!n)return a.vF.error("Failed to create shader"),null;if(e.shaderSource(n,r),e.compileShader(n),!e.getShaderParameter(n,e.COMPILE_STATUS)){const t=e.getShaderInfoLog(n);return a.vF.error("Shader compilation error:",t),e.deleteShader(n),null}return n}static createProgram(e,t,r){const n=this.createShader(e,e.VERTEX_SHADER,t),o=this.createShader(e,e.FRAGMENT_SHADER,r);if(!n||!o)return null;const i=e.createProgram();if(!i)return a.vF.error("Failed to create shader program"),null;if(e.attachShader(i,n),e.attachShader(i,o),e.linkProgram(i),!e.getProgramParameter(i,e.LINK_STATUS)){const t=e.getProgramInfoLog(i);return a.vF.error("Program linking error:",t),e.deleteProgram(i),null}const s={},l={},c=e.getProgramParameter(i,e.ACTIVE_UNIFORMS);for(let t=0;t<c;t++){const r=e.getActiveUniform(i,t);r&&(s[r.name]=e.getUniformLocation(i,r.name))}const u=e.getProgramParameter(i,e.ACTIVE_ATTRIBUTES);for(let t=0;t<u;t++){const r=e.getActiveAttrib(i,t);r&&(l[r.name]=e.getAttribLocation(i,r.name))}return e.deleteShader(n),e.deleteShader(o),{program:i,uniforms:s,attributes:l}}static createBuffer(e,t,r=e.STATIC_DRAW){const n=e.createBuffer();return n?(e.bindBuffer(e.ARRAY_BUFFER,n),e.bufferData(e.ARRAY_BUFFER,t,r),e.bindBuffer(e.ARRAY_BUFFER,null),n):(a.vF.error("Failed to create buffer"),null)}static createIndexBuffer(e,t,r=e.STATIC_DRAW){const n=e.createBuffer();return n?(e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n),e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,r),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),n):(a.vF.error("Failed to create index buffer"),null)}static createQuadMesh(e){const t=new Float32Array([-1,-1,0,0,1,-1,1,0,1,1,1,1,-1,1,0,1]),r=new Uint16Array([0,1,2,0,2,3]),n=this.createBuffer(e,t),o=this.createIndexBuffer(e,r);return n&&o?{vertexBuffer:n,indexBuffer:o,vertexCount:r.length}:null}static createCircleMesh(e,t=32){const r=[],n=[];r.push(0,0,.5,.5);for(let e=0;e<=t;e++){const n=e/t*Math.PI*2,o=Math.cos(n),i=Math.sin(n),a=.5*(o+1),s=.5*(i+1);r.push(o,i,a,s)}for(let e=1;e<=t;e++)n.push(0,e,e+1);n.push(0,t+1,1);const o=this.createBuffer(e,new Float32Array(r)),i=this.createIndexBuffer(e,new Uint16Array(n));return o&&i?{vertexBuffer:o,indexBuffer:i,vertexCount:n.length}:null}static setUniform1f(e,t,r){null!=t&&e.uniform1f(t,r)}static setUniform3f(e,t,r,n,o){null!=t&&e.uniform3f(t,r,n,o)}static setUniformMatrix3(e,t,r){null!=t&&e.uniformMatrix3fv(t,!1,r)}static setUniform2f(e,t,r,n){null!=t&&e.uniform2f(t,r,n)}static setUniform4f(e,t,r,n,o,i){null!=t&&e.uniform4f(t,r,n,o,i)}static createTexture(e,t,r,n){const o=e.createTexture();return o?(e.bindTexture(e.TEXTURE_2D,o),n?e.texImage2D(e.TEXTURE_2D,0,e.RGBA,t,r,0,e.RGBA,e.UNSIGNED_BYTE,n):e.texImage2D(e.TEXTURE_2D,0,e.RGBA,t,r,0,e.RGBA,e.UNSIGNED_BYTE,null),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.bindTexture(e.TEXTURE_2D,null),o):(a.vF.error("Failed to create texture"),null)}static generateNoiseTexture(e,t=256){const r=new Uint8Array(t*t*4);for(let e=0;e<t*t;e++){const t=Math.random();r[4*e]=255*t,r[4*e+1]=255*t,r[4*e+2]=255*t,r[4*e+3]=255}return this.createTexture(e,t,t,r)}static resizeCanvas(e,t,r){const n=t||e.clientWidth,o=r||e.clientHeight;return(e.width!==n||e.height!==o)&&(e.width=n,e.height=o,!0)}static createInstancedMesh(e,t,r){const n=e.createBuffer();return n?(e.bindBuffer(e.ARRAY_BUFFER,n),e.bufferData(e.ARRAY_BUFFER,13*r*4,e.DYNAMIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,null),{...t,instanceBuffer:n,instanceCount:0,maxInstances:r}):(a.vF.error("Failed to create instance buffer"),null)}static updateInstanceData(e,t,r){r.length>t.maxInstances&&(a.vF.warn(`Instance count ${r.length} exceeds max ${t.maxInstances}`),r=r.slice(0,t.maxInstances));const n=new Float32Array(13*r.length);for(let e=0;e<r.length;e++){const t=r[e],o=13*e;n[o]=t.position[0],n[o+1]=t.position[1],n[o+2]=t.scale,n[o+3]=t.rotation,n[o+4]=t.color[0],n[o+5]=t.color[1],n[o+6]=t.color[2],n[o+7]=t.color[3],n[o+8]=t.traits[0],n[o+9]=t.traits[1],n[o+10]=t.traits[2],n[o+11]=t.traits[3],n[o+12]=t.traits[4]}e.bindBuffer(e.ARRAY_BUFFER,t.instanceBuffer),e.bufferSubData(e.ARRAY_BUFFER,0,n),e.bindBuffer(e.ARRAY_BUFFER,null),t.instanceCount=r.length}static setupInstancedAttributes(e,t,r){e.bindBuffer(e.ARRAY_BUFFER,r.instanceBuffer);const n=t.attributes.a_instancePosition;void 0!==n&&n>=0&&(e.enableVertexAttribArray(n),e.vertexAttribPointer(n,2,e.FLOAT,!1,52,0),e.vertexAttribDivisor(n,1));const o=t.attributes.a_instanceScale;void 0!==o&&o>=0&&(e.enableVertexAttribArray(o),e.vertexAttribPointer(o,1,e.FLOAT,!1,52,8),e.vertexAttribDivisor(o,1));const i=t.attributes.a_instanceRotation;void 0!==i&&i>=0&&(e.enableVertexAttribArray(i),e.vertexAttribPointer(i,1,e.FLOAT,!1,52,12),e.vertexAttribDivisor(i,1));const a=t.attributes.a_instanceColor;void 0!==a&&a>=0&&(e.enableVertexAttribArray(a),e.vertexAttribPointer(a,4,e.FLOAT,!1,52,16),e.vertexAttribDivisor(a,1));const s=t.attributes.a_instanceTraits;void 0!==s&&s>=0&&(e.enableVertexAttribArray(s),e.vertexAttribPointer(s,5,e.FLOAT,!1,52,32),e.vertexAttribDivisor(s,1)),e.bindBuffer(e.ARRAY_BUFFER,null)}static drawInstanced(e,t){0!==t.instanceCount&&(e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t.indexBuffer),e.drawElementsInstanced(e.TRIANGLES,t.vertexCount,e.UNSIGNED_SHORT,0,t.instanceCount))}};var l,c=r(18);!function(e){e[e.ENERGY=0]="ENERGY",e[e.MUTATION=1]="MUTATION",e[e.CONSCIOUSNESS=2]="CONSCIOUSNESS",e[e.TRAIT=3]="TRAIT"}(l||(l={}));const u=class{constructor(e,t=100){this.program=null,this.particles=[],this.particleBuffer=null,this.lastEmission=0,this.gl=e,this.maxParticles=t,this.emissionRate=20,this.initializeShaders(),this.createBuffers()}initializeShaders(){const e=this.gl instanceof WebGL2RenderingContext,t=e?"#version 300 es\nprecision highp float;\n\nin vec2 a_position;\nin float a_age;\nin float a_energy;\nin vec2 a_velocity;\nin float a_type;\nin float a_size;\nin vec3 a_color;\n\nuniform float u_time;\nuniform float u_globalEnergy;\nuniform vec2 u_resolution;\n\nout float v_age;\nout float v_energy;\nout float v_alpha;\nout float v_type;\nout vec3 v_color;\n\nfloat noise(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 getTypeMovement(vec2 pos, float type, float age, float time) {\n    if (type == 0.0) { // ENERGY\n        // Spiral movement for energy particles\n        float angle = time * 2.0 + length(pos) * 5.0;\n        return vec2(cos(angle), sin(angle)) * 0.05;\n    } else if (type == 1.0) { // MUTATION\n        // Chaotic movement for mutations\n        vec2 chaos = vec2(\n            noise(pos + time * 0.1),\n            noise(pos.yx + time * 0.1)\n        ) * 2.0 - 1.0;\n        return chaos * 0.1;\n    } else if (type == 2.0) { // CONSCIOUSNESS\n        // Pulsing radial movement\n        float pulse = sin(time * 3.0) * 0.5 + 0.5;\n        return normalize(pos) * pulse * 0.03;\n    } else { // TRAIT\n        // Gentle oscillation\n        return vec2(sin(time + pos.x * 10.0), cos(time + pos.y * 10.0)) * 0.02;\n    }\n}\n\nvoid main() {\n    vec2 pos = a_position;\n    \n    float normalizedAge = a_age / 4.0; // Max age of 4 seconds\n    \n    // Basic movement\n    vec2 drift = a_velocity * a_age;\n    pos += drift;\n    \n    // Type-specific movement\n    pos += getTypeMovement(pos, a_type, normalizedAge, u_time);\n    \n    // Gravity towards center based on energy\n    if (u_globalEnergy > 0.3) {\n        vec2 toCenter = -normalize(pos) * u_globalEnergy * 0.08;\n        pos += toCenter * normalizedAge;\n    }\n    \n    float sizeMultiplier = a_type == 1.0 ? 1.5 : 1.0; // Larger mutation particles\n    float size = a_size * (1.0 - normalizedAge * 0.6) * sizeMultiplier * (6.0 + u_globalEnergy * 4.0);\n    \n    v_alpha = (1.0 - normalizedAge * normalizedAge) * a_energy;\n    v_age = normalizedAge;\n    v_energy = a_energy;\n    v_type = a_type;\n    v_color = a_color;\n    \n    gl_Position = vec4(pos, 0.0, 1.0);\n    gl_PointSize = size;\n}":"precision highp float;\n\nattribute vec2 a_position;\nattribute float a_age;\nattribute float a_energy;\nattribute vec2 a_velocity;\nattribute float a_type;\nattribute float a_size;\nattribute vec3 a_color;\n\nuniform float u_time;\nuniform float u_globalEnergy;\nuniform vec2 u_resolution;\n\nvarying float v_age;\nvarying float v_energy;\nvarying float v_alpha;\nvarying float v_type;\nvarying vec3 v_color;\n\nfloat noise(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main() {\n    vec2 pos = a_position;\n    float normalizedAge = a_age / 4.0;\n    vec2 drift = a_velocity * a_age;\n    pos += drift;\n    \n    float oscillation = sin(u_time * 2.0 + pos.x * 10.0) * 0.02;\n    pos.y += oscillation * (1.0 - normalizedAge);\n    \n    vec2 toCenter = -normalize(pos) * u_globalEnergy * 0.08;\n    pos += toCenter * normalizedAge;\n    \n    float size = a_size * (1.0 - normalizedAge * 0.6) * 8.0;\n    \n    v_alpha = (1.0 - normalizedAge) * a_energy;\n    v_age = normalizedAge;\n    v_energy = a_energy;\n    v_type = a_type;\n    v_color = a_color;\n    \n    gl_Position = vec4(pos, 0.0, 1.0);\n    gl_PointSize = size;\n}",r=e?"#version 300 es\nprecision highp float;\n\nin float v_age;\nin float v_energy;\nin float v_alpha;\nin float v_type;\nin vec3 v_color;\n\nuniform float u_time;\nuniform float u_mutation;\n\nout vec4 fragColor;\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main() {\n    vec2 coord = gl_PointCoord - vec2(0.5);\n    float dist = length(coord);\n    \n    if (v_type == 0.0) { // ENERGY particles\n        float circle = smoothstep(0.5, 0.2, dist);\n        float pulse = sin(u_time * 6.0 + v_energy * 15.0) * 0.4 + 0.6;\n        vec3 color = v_color * pulse;\n        float alpha = circle * v_alpha;\n        fragColor = vec4(color, alpha);\n        \n    } else if (v_type == 1.0) { // MUTATION particles\n        float star = 0.0;\n        for (int i = 0; i < 5; i++) {\n            float angle = float(i) * 1.2566 + u_time; // 2*PI/5\n            vec2 starPoint = vec2(cos(angle), sin(angle)) * 0.3;\n            star = max(star, 1.0 - smoothstep(0.0, 0.1, length(coord - starPoint)));\n        }\n        float chaos = hash(coord + u_time * 0.1);\n        vec3 color = mix(v_color, vec3(1.0, 0.0, 1.0), chaos * 0.5);\n        float alpha = (star + smoothstep(0.5, 0.0, dist)) * v_alpha * (0.7 + chaos * 0.3);\n        fragColor = vec4(color, alpha);\n        \n    } else if (v_type == 2.0) { // CONSCIOUSNESS particles\n        float ring = smoothstep(0.5, 0.4, dist) - smoothstep(0.4, 0.3, dist);\n        float center = smoothstep(0.2, 0.0, dist);\n        float glow = exp(-dist * 3.0);\n        \n        float meditation = sin(u_time * 2.0 + v_energy * 8.0) * 0.3 + 0.7;\n        vec3 color = v_color * meditation;\n        float alpha = (ring + center * 0.6 + glow * 0.3) * v_alpha;\n        fragColor = vec4(color, alpha);\n        \n    } else { // TRAIT particles\n        float circle = smoothstep(0.5, 0.3, dist);\n        float sparkle = step(0.95, hash(coord + u_time * 0.01));\n        vec3 color = v_color + vec3(sparkle * 0.5);\n        float alpha = circle * v_alpha * (0.8 + sparkle * 0.4);\n        fragColor = vec4(color, alpha);\n    }\n}":"precision highp float;\n\nvarying float v_age;\nvarying float v_energy;\nvarying float v_alpha;\nvarying float v_type;\nvarying vec3 v_color;\n\nuniform float u_time;\nuniform float u_mutation;\n\nvoid main() {\n    vec2 coord = gl_PointCoord - vec2(0.5);\n    float dist = length(coord);\n    \n    float circle = smoothstep(0.5, 0.3, dist);\n    float pulse = sin(u_time * 4.0 + v_energy * 10.0) * 0.3 + 0.7;\n    \n    vec3 color = v_color * pulse;\n    float alpha = circle * v_alpha;\n    \n    gl_FragColor = vec4(color, alpha);\n}";this.program=s.createProgram(this.gl,t,r)}createBuffers(){this.particleBuffer=this.gl.createBuffer()}emitParticle(e,t,r,n=l.ENERGY){this.particles.length>=this.maxParticles&&this.particles.shift();const o=c.Dm.random()*Math.PI*2,i=this.getSpeedForType(n),a=this.getColorForType(n,r),s=this.getSizeForType(n,r),u={x:e+.02*(c.Dm.random()-.5),y:t+.02*(c.Dm.random()-.5),vx:Math.cos(o)*i,vy:Math.sin(o)*i,energy:r*(.7+.3*c.Dm.random()),age:0,maxAge:this.getMaxAgeForType(n),type:n,size:s,color:a,mutation:n===l.MUTATION};this.particles.push(u)}getSpeedForType(e){switch(e){case l.ENERGY:return.03+.07*c.Dm.random();case l.MUTATION:return.08+.12*c.Dm.random();case l.CONSCIOUSNESS:return.01+.03*c.Dm.random();case l.TRAIT:return.02+.05*c.Dm.random();default:return.05}}getColorForType(e,t){const r=.8+.2*t;switch(e){case l.ENERGY:return[0*r,.878*r,1*r];case l.MUTATION:return[1*r,.2*r,.8*r];case l.CONSCIOUSNESS:return[.9*r,.7*r,.2*r];case l.TRAIT:return[.6*r,.4*r,.9*r];default:return[1,1,1]}}getSizeForType(e,t){const r=.8+.4*t;switch(e){case l.ENERGY:return 1*r;case l.MUTATION:return 1.4*r;case l.CONSCIOUSNESS:return 1.2*r;case l.TRAIT:return.8*r;default:return r}}getMaxAgeForType(e){switch(e){case l.ENERGY:return 2+2*c.Dm.random();case l.MUTATION:return 3+3*c.Dm.random();case l.CONSCIOUSNESS:return 4+4*c.Dm.random();case l.TRAIT:return 1.5+1.5*c.Dm.random();default:return 2}}emitMutationBurst(e,t,r){const n=Math.floor(5+10*r);for(let o=0;o<n;o++)this.emitParticle(e,t,r,l.MUTATION)}emitConsciousnessPulse(e,t,r){const n=Math.floor(3+5*r);for(let o=0;o<n;o++)this.emitParticle(e,t,r,l.CONSCIOUSNESS)}emitTraitParticles(e,t,r){for(const[n,o]of Object.entries(r))o>.3&&c.Dm.random()<o&&this.emitParticle(e,t,o,l.TRAIT)}update(e,t,r,n){for(let t=this.particles.length-1;t>=0;t--){const r=this.particles[t];r.age+=e,r.age>=r.maxAge?this.particles.splice(t,1):(r.x+=r.vx*e,r.y+=r.vy*e)}const o=Date.now()/1e3,i=o-this.lastEmission,a=Math.floor(i*this.emissionRate*t);for(let e=0;e<a;e++){const e=c.Dm.random()*Math.PI*2,o=.1+.2*c.Dm.random(),i=r+Math.cos(e)*o,a=n+Math.sin(e)*o;this.emitParticle(i,a,t)}a>0&&(this.lastEmission=o)}render(e,t,r=0){if(!this.program||0===this.particles.length)return;const n=this.gl,o=[];this.particles.forEach((e=>{o.push(e.x,e.y,e.age,e.energy,e.vx,e.vy,e.type,e.size,e.color[0],e.color[1],e.color[2])})),this.particleBuffer&&(n.bindBuffer(n.ARRAY_BUFFER,this.particleBuffer),n.bufferData(n.ARRAY_BUFFER,new Float32Array(o),n.DYNAMIC_DRAW)),n.enable(n.BLEND),n.blendFunc(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA),n.useProgram(this.program.program);const i=44;let a=0;const l=this.program.attributes.a_position;void 0!==l&&l>=0&&(n.enableVertexAttribArray(l),n.vertexAttribPointer(l,2,n.FLOAT,!1,i,a)),a+=8;const c=this.program.attributes.a_age;void 0!==c&&c>=0&&(n.enableVertexAttribArray(c),n.vertexAttribPointer(c,1,n.FLOAT,!1,i,a)),a+=4;const u=this.program.attributes.a_energy;void 0!==u&&u>=0&&(n.enableVertexAttribArray(u),n.vertexAttribPointer(u,1,n.FLOAT,!1,i,a)),a+=4;const f=this.program.attributes.a_velocity;void 0!==f&&f>=0&&(n.enableVertexAttribArray(f),n.vertexAttribPointer(f,2,n.FLOAT,!1,i,a)),a+=8;const m=this.program.attributes.a_type;void 0!==m&&m>=0&&(n.enableVertexAttribArray(m),n.vertexAttribPointer(m,1,n.FLOAT,!1,i,a)),a+=4;const v=this.program.attributes.a_size;void 0!==v&&v>=0&&(n.enableVertexAttribArray(v),n.vertexAttribPointer(v,1,n.FLOAT,!1,i,a)),a+=4;const h=this.program.attributes.a_color;void 0!==h&&h>=0&&(n.enableVertexAttribArray(h),n.vertexAttribPointer(h,3,n.FLOAT,!1,i,a)),s.setUniform1f(n,this.program.uniforms.u_time,e),s.setUniform1f(n,this.program.uniforms.u_globalEnergy,t),s.setUniform1f(n,this.program.uniforms.u_mutation,r),this.program.uniforms.u_resolution&&n.uniform2f(this.program.uniforms.u_resolution,n.canvas.width,n.canvas.height);const d=n.isEnabled(n.DEPTH_TEST);d&&n.disable(n.DEPTH_TEST),n.drawArrays(n.POINTS,0,this.particles.length),d&&n.enable(n.DEPTH_TEST),void 0!==l&&l>=0&&n.disableVertexAttribArray(l),void 0!==c&&c>=0&&n.disableVertexAttribArray(c),void 0!==u&&u>=0&&n.disableVertexAttribArray(u),void 0!==f&&f>=0&&n.disableVertexAttribArray(f),void 0!==m&&m>=0&&n.disableVertexAttribArray(m),void 0!==v&&v>=0&&n.disableVertexAttribArray(v),void 0!==h&&h>=0&&n.disableVertexAttribArray(h)}destroy(){this.gl&&this.program&&this.gl.deleteProgram(this.program.program),this.gl&&this.particleBuffer&&this.gl.deleteBuffer(this.particleBuffer),this.particles=[]}};async function f(e){try{const t=await fetch(e);if(!t.ok)throw new Error(`Failed to load shader: ${t.statusText}`);return await t.text()}catch(t){throw a.vF.error(`Failed to load shader ${e}:`,t),t}}const m="\nprecision highp float;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nuniform float u_time;\nuniform float u_complexity;\nuniform float u_fluidity;\nuniform float u_consciousness;\nuniform mat3 u_transform;\nuniform float u_curiosity;\nuniform float u_focus;\nuniform float u_rhythm;\nuniform float u_empathy;\nuniform float u_creativity;\nvarying vec2 v_texCoord;\nvarying vec2 v_position;\nvarying float v_pattern;\nvarying float v_energy;\nvarying float v_consciousness;\n\nfloat noise(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main() {\n    v_texCoord = a_texCoord;\n    v_position = a_position;\n    vec2 pos = a_position;\n    float fluidEffect = sin(u_time * u_rhythm + pos.x * u_empathy) * u_fluidity;\n    pos.x += fluidEffect * 0.1;\n    v_pattern = noise(pos * 2.0 + u_time * 0.1);\n    v_energy = (1.0 - length(pos)) * u_consciousness;\n    v_consciousness = u_consciousness;\n    vec3 worldPos = u_transform * vec3(pos, 1.0);\n    gl_Position = vec4(worldPos.xy, 0.0, 1.0);\n}",v="\nprecision highp float;\n#define TEX texture2D\nvarying vec2 v_texCoord;\nvarying vec2 v_position;\nvarying float v_pattern;\nvarying float v_energy;\nvarying float v_consciousness;\nuniform float u_time;\nuniform float u_mutation;\nuniform vec3 u_primaryColor;\nuniform vec3 u_secondaryColor;\nuniform vec3 u_accentColor;\nuniform sampler2D u_noiseTexture;\nuniform float u_curiosity;\nuniform float u_focus;\nuniform float u_rhythm;\nuniform float u_empathy;\nuniform float u_creativity;\n\nvoid main() {\n    float distanceFromCenter = length(v_position);\n    vec2 noiseCoord = v_texCoord + u_time * 0.05;\n    float noise1 = TEX(u_noiseTexture, noiseCoord).r;\n    float organicPattern = v_pattern + noise1 * 0.3;\n    vec3 baseColor = mix(u_primaryColor, u_secondaryColor, organicPattern);\n    float consciousnessGlow = v_consciousness * exp(-distanceFromCenter * 2.0);\n    baseColor = mix(baseColor, u_accentColor, consciousnessGlow * 0.4);\n    float alpha = smoothstep(1.0, 0.7, distanceFromCenter) * (0.8 + v_energy * 0.2);\n    gl_FragColor = vec4(baseColor, alpha * 0.9);\n}",h=({width:e=400,height:t=300,className:r=""})=>{const l=(0,o.useRef)(null),c=(0,o.useRef)(null),h=(0,o.useRef)(null),d=(0,o.useRef)(null),g=(0,o.useRef)(null),_=(0,o.useRef)(null),p=(0,o.useRef)(null),y=(0,o.useRef)(Date.now()),A=(0,o.useRef)(Date.now()),b=(0,o.useRef)(!1),x=(0,o.useRef)(60),E=(0,o.useRef)(16.67),{organism:T}=(0,i.YT)(),[R,F]=(0,o.useState)(!1),[C,U]=(0,o.useState)(null);return(0,o.useEffect)((()=>{const e=()=>{const e=document.hidden?10:T&&T.energy&&T.energy<30?30:T&&T.energy&&T.energy<60?45:60;e!==x.current&&(x.current=e,E.current=1e3/e,a.vF.info(`WebGL FPS adaptatif: ${e} FPS`))},t=setInterval(e,2e3),r=()=>{e()};return document.addEventListener("visibilitychange",r),()=>{clearInterval(t),document.removeEventListener("visibilitychange",r)}}),[T?.energy]),(0,o.useEffect)((()=>{const e=l.current;if(!e)return;const t=e=>{e.preventDefault(),b.current=!0,U("WebGL context lost - attempting recovery..."),a.vF.warn("WebGL context lost")},r=()=>{b.current=!1,U(null),a.vF.info("WebGL context restored"),n()};e.addEventListener("webglcontextlost",t),e.addEventListener("webglcontextrestored",r);const n=async()=>{let t=null;try{if(!window.WebGLRenderingContext)throw new Error("WebGL not available in this browser");t=setTimeout((()=>{U("WebGL initialization timeout - switching to 2D fallback"),a.vF.warn("WebGL initialization timeout")}),5e3);const r={alpha:!0,depth:!1,stencil:!1,antialias:!0,premultipliedAlpha:!1,preserveDrawingBuffer:!1,powerPreference:"default",failIfMajorPerformanceCaveat:!1};let n,o,i=null,l=!1;try{if(i=e.getContext("webgl2",r),i){const e=i.getSupportedExtensions()||[];l=!0,a.vF.info("WebGL2 context acquired with extensions:",e)}}catch(e){a.vF.warn("WebGL2 initialization failed:",e)}if(!i)try{i=e.getContext("webgl",r),i&&a.vF.info("Falling back to WebGL1")}catch(e){a.vF.warn("WebGL1 initialization failed:",e)}if(!i)try{i=e.getContext("experimental-webgl",r),i&&a.vF.warn("Using experimental WebGL context")}catch(e){a.vF.error("All WebGL contexts failed:",e)}if(!i)throw new Error("WebGL not supported - falling back to minimal 2D renderer");c.current=i;try{l?(a.vF.info("Loading WebGL2 enhanced shaders"),n=await f(chrome?.runtime?.getURL?chrome.runtime.getURL("shaders/enhanced-organism.vert"):"/src/shaders/enhanced-organism.vert"),o=await f(chrome?.runtime?.getURL?chrome.runtime.getURL("shaders/enhanced-organism.frag"):"/src/shaders/enhanced-organism.frag")):(a.vF.info("Using WebGL1 fallback shaders"),n=m,o=v)}catch(e){a.vF.warn("Failed to load enhanced shaders, using fallback:",e),n=m,o=v}const p=s.createProgram(i,n,o);if(!p)throw new Error("Failed to create shader program");h.current=p;const y=s.createCircleMesh(i,64);if(!y)throw new Error("Failed to create mesh");d.current=y;const A=s.generateNoiseTexture(i,256);if(!A)throw new Error("Failed to create noise texture");g.current=A;const b=new u(i,150);_.current=b,i.enable(i.BLEND),i.blendFunc(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA),i.clearColor(0,0,0,0),t&&clearTimeout(t),F(!0),a.vF.info("WebGL Organism Viewer initialized successfully")}catch(e){t&&clearTimeout(t);const r=e instanceof Error?e.message:"Unknown WebGL error";U(r),a.vF.error("WebGL initialization failed:",r)}};return n(),()=>{e.removeEventListener("webglcontextlost",t),e.removeEventListener("webglcontextrestored",r)}}),[]),(0,o.useEffect)((()=>{if(!R||!T||!c.current||!h.current||!d.current||b.current)return;const r=c.current,n=h.current,o=d.current,i=l.current,a=_.current,u=()=>{if(!(i&&r&&n&&o))return;const l=Date.now(),c=(l-A.current)/1e3;if(c<E.current/1e3)return void(p.current=requestAnimationFrame(u));A.current=l;const f=window.devicePixelRatio||1,m=e,v=t,h=Math.floor(m*f),d=Math.floor(v*f);i.width===h&&i.height===d||(i.width=h,i.height=d,i.className="webgl-canvas webgl-canvas-resized"),r.viewport(0,0,i.width,i.height),r.clear(r.COLOR_BUFFER_BIT),r.useProgram(n.program),r.bindBuffer(r.ARRAY_BUFFER,o.vertexBuffer),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,o.indexBuffer);const _=n.attributes.a_position,b=n.attributes.a_texCoord;void 0!==_&&_>=0&&(r.enableVertexAttribArray(_),r.vertexAttribPointer(_,2,r.FLOAT,!1,16,0)),void 0!==b&&b>=0&&(r.enableVertexAttribArray(b),r.vertexAttribPointer(b,2,r.FLOAT,!1,16,8));const x=(Date.now()-y.current)/1e3,R=T.traits||{curiosity:.5,focus:.5,rhythm:.5,empathy:.5,creativity:.5},F=new Float32Array([1,0,0,0,1,0,0,0,1]),C=.8+.4*R.creativity,U=x*R.rhythm*.1,S=Math.cos(U),w=Math.sin(U);F[0]=S*C,F[1]=-w*C,F[3]=w*C,F[4]=S*C,n.uniforms.u_time&&s.setUniform1f(r,n.uniforms.u_time,x),n.uniforms.u_complexity&&s.setUniform1f(r,n.uniforms.u_complexity,.7+.3*R.creativity),n.uniforms.u_fluidity&&s.setUniform1f(r,n.uniforms.u_fluidity,.4+.6*R.empathy),n.uniforms.u_consciousness&&s.setUniform1f(r,n.uniforms.u_consciousness,T.consciousness||.5),n.uniforms.u_energy&&s.setUniform1f(r,n.uniforms.u_energy,(T.energy||50)/100),n.uniforms.u_mutation&&s.setUniform1f(r,n.uniforms.u_mutation,.1+.01*(T.generation||0)),n.uniforms.u_transform&&s.setUniformMatrix3(r,n.uniforms.u_transform,F),n.uniforms.u_resolution&&r.uniform2f(n.uniforms.u_resolution,i.width,i.height),n.uniforms.u_curiosity&&s.setUniform1f(r,n.uniforms.u_curiosity,R.curiosity),n.uniforms.u_focus&&s.setUniform1f(r,n.uniforms.u_focus,R.focus),n.uniforms.u_rhythm&&s.setUniform1f(r,n.uniforms.u_rhythm,Math.max(.1,R.rhythm)),n.uniforms.u_empathy&&s.setUniform1f(r,n.uniforms.u_empathy,R.empathy),n.uniforms.u_creativity&&s.setUniform1f(r,n.uniforms.u_creativity,R.creativity);const N=[0+.3*R.curiosity,.878-.2*R.focus,1-.3*R.empathy],P=[.373+.2*R.creativity,.765+.1*R.rhythm,.969-.1*R.focus],B=[.612+.3*R.empathy,.416+.2*R.curiosity,.875-.1*R.creativity];if(n.uniforms.u_primaryColor&&s.setUniform3f(r,n.uniforms.u_primaryColor,N[0],N[1],N[2]),n.uniforms.u_secondaryColor&&s.setUniform3f(r,n.uniforms.u_secondaryColor,P[0],P[1],P[2]),n.uniforms.u_accentColor&&s.setUniform3f(r,n.uniforms.u_accentColor,B[0],B[1],B[2]),g.current&&n.uniforms.u_noiseTexture&&(r.activeTexture(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,g.current),r.uniform1i(n.uniforms.u_noiseTexture,0)),r.drawElements(r.TRIANGLES,o.vertexCount,r.UNSIGNED_SHORT,0),a){const e=(T.energy||50)/100;a.update(c,e,0,0),a.render(x,e)}p.current=requestAnimationFrame(u)};return u(),()=>{p.current&&cancelAnimationFrame(p.current)}}),[R,T,e,t]),(0,o.useEffect)((()=>()=>{p.current&&cancelAnimationFrame(p.current),_.current&&_.current.destroy();const e=c.current;e&&h.current&&e.deleteProgram(h.current.program),e&&d.current&&(e.deleteBuffer(d.current.vertexBuffer),e.deleteBuffer(d.current.indexBuffer)),e&&g.current&&e.deleteTexture(g.current)}),[]),C?(0,n.jsx)("div",{className:`webgl-error ${r}`,children:(0,n.jsxs)("div",{className:"error-content",children:[(0,n.jsx)("div",{className:"error-icon",children:"‚ö†Ô∏è"}),(0,n.jsxs)("div",{className:"error-message",children:["WebGL Error: ",C]}),(0,n.jsx)("div",{className:"error-hint",children:"Your browser may not support WebGL"})]})}):T?(0,n.jsxs)("div",{className:`webgl-organism-viewer ${r}`,children:[(0,n.jsx)("canvas",{ref:l,width:e,height:t,className:"webgl-canvas"}),(0,n.jsxs)("div",{className:"organism-info-overlay",children:[(0,n.jsxs)("div",{className:"info-item",children:[(0,n.jsx)("span",{children:"Gen"}),(0,n.jsx)("span",{children:T.generation})]}),(0,n.jsxs)("div",{className:"info-item",children:[(0,n.jsx)("span",{children:"ADN"}),(0,n.jsxs)("span",{children:[T.dna?.substring(0,6),"..."]})]}),(0,n.jsxs)("div",{className:"info-item",children:[(0,n.jsx)("span",{children:"√ânergie"}),(0,n.jsx)("span",{children:Math.round(T.energy||0)})]})]})]}):(0,n.jsxs)("div",{className:`organism-loading ${r}`,children:[(0,n.jsx)("div",{className:"loading-spinner",children:"üß¨"}),(0,n.jsx)("div",{children:"Loading organism..."})]})},d=h}}]);