"use strict";(self.webpackChunksymbiont=self.webpackChunksymbiont||[]).push([[534],{534:(e,t,r)=>{r.r(t),r.d(t,{WebGLOrganismViewer:()=>C,default:()=>S});var n=r(848),i=r(540),o=r(23),a=r(513);const s=class{static createShader(e,t,r){const n=e.createShader(t);if(!n)return a.vF.error("Failed to create shader"),null;if(e.shaderSource(n,r),e.compileShader(n),!e.getShaderParameter(n,e.COMPILE_STATUS)){const t=e.getShaderInfoLog(n);return a.vF.error("Shader compilation error:",t),e.deleteShader(n),null}return n}static createProgram(e,t,r){const n=this.createShader(e,e.VERTEX_SHADER,t),i=this.createShader(e,e.FRAGMENT_SHADER,r);if(!n||!i)return null;const o=e.createProgram();if(!o)return a.vF.error("Failed to create shader program"),null;if(e.attachShader(o,n),e.attachShader(o,i),e.linkProgram(o),!e.getProgramParameter(o,e.LINK_STATUS)){const t=e.getProgramInfoLog(o);return a.vF.error("Program linking error:",t),e.deleteProgram(o),null}const s={},l={},c=e.getProgramParameter(o,e.ACTIVE_UNIFORMS);for(let t=0;t<c;t++){const r=e.getActiveUniform(o,t);r&&(s[r.name]=e.getUniformLocation(o,r.name))}const u=e.getProgramParameter(o,e.ACTIVE_ATTRIBUTES);for(let t=0;t<u;t++){const r=e.getActiveAttrib(o,t);r&&(l[r.name]=e.getAttribLocation(o,r.name))}return e.deleteShader(n),e.deleteShader(i),{program:o,uniforms:s,attributes:l}}static createBuffer(e,t,r=e.STATIC_DRAW){const n=e.createBuffer();return n?(e.bindBuffer(e.ARRAY_BUFFER,n),e.bufferData(e.ARRAY_BUFFER,t,r),e.bindBuffer(e.ARRAY_BUFFER,null),n):(a.vF.error("Failed to create buffer"),null)}static createIndexBuffer(e,t,r=e.STATIC_DRAW){const n=e.createBuffer();return n?(e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n),e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,r),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),n):(a.vF.error("Failed to create index buffer"),null)}static createQuadMesh(e){const t=new Float32Array([-1,-1,0,0,1,-1,1,0,1,1,1,1,-1,1,0,1]),r=new Uint16Array([0,1,2,0,2,3]),n=this.createBuffer(e,t),i=this.createIndexBuffer(e,r);return n&&i?{vertexBuffer:n,indexBuffer:i,vertexCount:r.length}:null}static createCircleMesh(e,t=32){const r=[],n=[];r.push(0,0,.5,.5);for(let e=0;e<=t;e++){const n=e/t*Math.PI*2,i=Math.cos(n),o=Math.sin(n),a=.5*(i+1),s=.5*(o+1);r.push(i,o,a,s)}for(let e=1;e<=t;e++)n.push(0,e,e+1);n.push(0,t+1,1);const i=this.createBuffer(e,new Float32Array(r)),o=this.createIndexBuffer(e,new Uint16Array(n));return i&&o?{vertexBuffer:i,indexBuffer:o,vertexCount:n.length}:null}static setUniform1f(e,t,r){null!=t&&e.uniform1f(t,r)}static setUniform3f(e,t,r,n,i){null!=t&&e.uniform3f(t,r,n,i)}static setUniformMatrix3(e,t,r){null!=t&&e.uniformMatrix3fv(t,!1,r)}static setUniform2f(e,t,r,n){null!=t&&e.uniform2f(t,r,n)}static setUniform4f(e,t,r,n,i,o){null!=t&&e.uniform4f(t,r,n,i,o)}static createTexture(e,t,r,n){const i=e.createTexture();return i?(e.bindTexture(e.TEXTURE_2D,i),n?e.texImage2D(e.TEXTURE_2D,0,e.RGBA,t,r,0,e.RGBA,e.UNSIGNED_BYTE,n):e.texImage2D(e.TEXTURE_2D,0,e.RGBA,t,r,0,e.RGBA,e.UNSIGNED_BYTE,null),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.bindTexture(e.TEXTURE_2D,null),i):(a.vF.error("Failed to create texture"),null)}static generateNoiseTexture(e,t=256){const r=new Uint8Array(t*t*4);for(let e=0;e<t*t;e++){const t=Math.random();r[4*e]=255*t,r[4*e+1]=255*t,r[4*e+2]=255*t,r[4*e+3]=255}return this.createTexture(e,t,t,r)}static resizeCanvas(e,t,r){const n=t||e.clientWidth,i=r||e.clientHeight;return(e.width!==n||e.height!==i)&&(e.width=n,e.height=i,!0)}static createInstancedMesh(e,t,r){const n=e.createBuffer();return n?(e.bindBuffer(e.ARRAY_BUFFER,n),e.bufferData(e.ARRAY_BUFFER,13*r*4,e.DYNAMIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,null),{...t,instanceBuffer:n,instanceCount:0,maxInstances:r}):(a.vF.error("Failed to create instance buffer"),null)}static updateInstanceData(e,t,r){r.length>t.maxInstances&&(a.vF.warn(`Instance count ${r.length} exceeds max ${t.maxInstances}`),r=r.slice(0,t.maxInstances));const n=new Float32Array(13*r.length);for(let e=0;e<r.length;e++){const t=r[e],i=13*e;n[i]=t.position[0],n[i+1]=t.position[1],n[i+2]=t.scale,n[i+3]=t.rotation,n[i+4]=t.color[0],n[i+5]=t.color[1],n[i+6]=t.color[2],n[i+7]=t.color[3],n[i+8]=t.traits[0],n[i+9]=t.traits[1],n[i+10]=t.traits[2],n[i+11]=t.traits[3],n[i+12]=t.traits[4]}e.bindBuffer(e.ARRAY_BUFFER,t.instanceBuffer),e.bufferSubData(e.ARRAY_BUFFER,0,n),e.bindBuffer(e.ARRAY_BUFFER,null),t.instanceCount=r.length}static setupInstancedAttributes(e,t,r){e.bindBuffer(e.ARRAY_BUFFER,r.instanceBuffer);const n=t.attributes.a_instancePosition;void 0!==n&&n>=0&&(e.enableVertexAttribArray(n),e.vertexAttribPointer(n,2,e.FLOAT,!1,52,0),e.vertexAttribDivisor(n,1));const i=t.attributes.a_instanceScale;void 0!==i&&i>=0&&(e.enableVertexAttribArray(i),e.vertexAttribPointer(i,1,e.FLOAT,!1,52,8),e.vertexAttribDivisor(i,1));const o=t.attributes.a_instanceRotation;void 0!==o&&o>=0&&(e.enableVertexAttribArray(o),e.vertexAttribPointer(o,1,e.FLOAT,!1,52,12),e.vertexAttribDivisor(o,1));const a=t.attributes.a_instanceColor;void 0!==a&&a>=0&&(e.enableVertexAttribArray(a),e.vertexAttribPointer(a,4,e.FLOAT,!1,52,16),e.vertexAttribDivisor(a,1));const s=t.attributes.a_instanceTraits;void 0!==s&&s>=0&&(e.enableVertexAttribArray(s),e.vertexAttribPointer(s,5,e.FLOAT,!1,52,32),e.vertexAttribDivisor(s,1)),e.bindBuffer(e.ARRAY_BUFFER,null)}static drawInstanced(e,t){0!==t.instanceCount&&(e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t.indexBuffer),e.drawElementsInstanced(e.TRIANGLES,t.vertexCount,e.UNSIGNED_SHORT,0,t.instanceCount))}};var l,c=r(18);!function(e){e[e.ENERGY=0]="ENERGY",e[e.MUTATION=1]="MUTATION",e[e.CONSCIOUSNESS=2]="CONSCIOUSNESS",e[e.TRAIT=3]="TRAIT"}(l||(l={}));const u=class{constructor(e,t=100){this.program=null,this.particles=[],this.particleBuffer=null,this.lastEmission=0,this.gl=e,this.maxParticles=t,this.emissionRate=20,this.initializeShaders(),this.createBuffers()}initializeShaders(){const e=this.gl instanceof WebGL2RenderingContext,t=e?"#version 300 es\nprecision highp float;\n\nin vec2 a_position;\nin float a_age;\nin float a_energy;\nin vec2 a_velocity;\nin float a_type;\nin float a_size;\nin vec3 a_color;\n\nuniform float u_time;\nuniform float u_globalEnergy;\nuniform vec2 u_resolution;\n\nout float v_age;\nout float v_energy;\nout float v_alpha;\nout float v_type;\nout vec3 v_color;\n\nfloat noise(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 getTypeMovement(vec2 pos, float type, float age, float time) {\n    if (type == 0.0) { // ENERGY\n        // Spiral movement for energy particles\n        float angle = time * 2.0 + length(pos) * 5.0;\n        return vec2(cos(angle), sin(angle)) * 0.05;\n    } else if (type == 1.0) { // MUTATION\n        // Chaotic movement for mutations\n        vec2 chaos = vec2(\n            noise(pos + time * 0.1),\n            noise(pos.yx + time * 0.1)\n        ) * 2.0 - 1.0;\n        return chaos * 0.1;\n    } else if (type == 2.0) { // CONSCIOUSNESS\n        // Pulsing radial movement\n        float pulse = sin(time * 3.0) * 0.5 + 0.5;\n        return normalize(pos) * pulse * 0.03;\n    } else { // TRAIT\n        // Gentle oscillation\n        return vec2(sin(time + pos.x * 10.0), cos(time + pos.y * 10.0)) * 0.02;\n    }\n}\n\nvoid main() {\n    vec2 pos = a_position;\n    \n    float normalizedAge = a_age / 4.0; // Max age of 4 seconds\n    \n    // Basic movement\n    vec2 drift = a_velocity * a_age;\n    pos += drift;\n    \n    // Type-specific movement\n    pos += getTypeMovement(pos, a_type, normalizedAge, u_time);\n    \n    // Gravity towards center based on energy\n    if (u_globalEnergy > 0.3) {\n        vec2 toCenter = -normalize(pos) * u_globalEnergy * 0.08;\n        pos += toCenter * normalizedAge;\n    }\n    \n    float sizeMultiplier = a_type == 1.0 ? 1.5 : 1.0; // Larger mutation particles\n    float size = a_size * (1.0 - normalizedAge * 0.6) * sizeMultiplier * (6.0 + u_globalEnergy * 4.0);\n    \n    v_alpha = (1.0 - normalizedAge * normalizedAge) * a_energy;\n    v_age = normalizedAge;\n    v_energy = a_energy;\n    v_type = a_type;\n    v_color = a_color;\n    \n    gl_Position = vec4(pos, 0.0, 1.0);\n    gl_PointSize = size;\n}":"precision highp float;\n\nattribute vec2 a_position;\nattribute float a_age;\nattribute float a_energy;\nattribute vec2 a_velocity;\nattribute float a_type;\nattribute float a_size;\nattribute vec3 a_color;\n\nuniform float u_time;\nuniform float u_globalEnergy;\nuniform vec2 u_resolution;\n\nvarying float v_age;\nvarying float v_energy;\nvarying float v_alpha;\nvarying float v_type;\nvarying vec3 v_color;\n\nfloat noise(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main() {\n    vec2 pos = a_position;\n    float normalizedAge = a_age / 4.0;\n    vec2 drift = a_velocity * a_age;\n    pos += drift;\n    \n    float oscillation = sin(u_time * 2.0 + pos.x * 10.0) * 0.02;\n    pos.y += oscillation * (1.0 - normalizedAge);\n    \n    vec2 toCenter = -normalize(pos) * u_globalEnergy * 0.08;\n    pos += toCenter * normalizedAge;\n    \n    float size = a_size * (1.0 - normalizedAge * 0.6) * 8.0;\n    \n    v_alpha = (1.0 - normalizedAge) * a_energy;\n    v_age = normalizedAge;\n    v_energy = a_energy;\n    v_type = a_type;\n    v_color = a_color;\n    \n    gl_Position = vec4(pos, 0.0, 1.0);\n    gl_PointSize = size;\n}",r=e?"#version 300 es\nprecision highp float;\n\nin float v_age;\nin float v_energy;\nin float v_alpha;\nin float v_type;\nin vec3 v_color;\n\nuniform float u_time;\nuniform float u_mutation;\n\nout vec4 fragColor;\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main() {\n    vec2 coord = gl_PointCoord - vec2(0.5);\n    float dist = length(coord);\n    \n    if (v_type == 0.0) { // ENERGY particles\n        float circle = smoothstep(0.5, 0.2, dist);\n        float pulse = sin(u_time * 6.0 + v_energy * 15.0) * 0.4 + 0.6;\n        vec3 color = v_color * pulse;\n        float alpha = circle * v_alpha;\n        fragColor = vec4(color, alpha);\n        \n    } else if (v_type == 1.0) { // MUTATION particles\n        float star = 0.0;\n        for (int i = 0; i < 5; i++) {\n            float angle = float(i) * 1.2566 + u_time; // 2*PI/5\n            vec2 starPoint = vec2(cos(angle), sin(angle)) * 0.3;\n            star = max(star, 1.0 - smoothstep(0.0, 0.1, length(coord - starPoint)));\n        }\n        float chaos = hash(coord + u_time * 0.1);\n        vec3 color = mix(v_color, vec3(1.0, 0.0, 1.0), chaos * 0.5);\n        float alpha = (star + smoothstep(0.5, 0.0, dist)) * v_alpha * (0.7 + chaos * 0.3);\n        fragColor = vec4(color, alpha);\n        \n    } else if (v_type == 2.0) { // CONSCIOUSNESS particles\n        float ring = smoothstep(0.5, 0.4, dist) - smoothstep(0.4, 0.3, dist);\n        float center = smoothstep(0.2, 0.0, dist);\n        float glow = exp(-dist * 3.0);\n        \n        float meditation = sin(u_time * 2.0 + v_energy * 8.0) * 0.3 + 0.7;\n        vec3 color = v_color * meditation;\n        float alpha = (ring + center * 0.6 + glow * 0.3) * v_alpha;\n        fragColor = vec4(color, alpha);\n        \n    } else { // TRAIT particles\n        float circle = smoothstep(0.5, 0.3, dist);\n        float sparkle = step(0.95, hash(coord + u_time * 0.01));\n        vec3 color = v_color + vec3(sparkle * 0.5);\n        float alpha = circle * v_alpha * (0.8 + sparkle * 0.4);\n        fragColor = vec4(color, alpha);\n    }\n}":"precision highp float;\n\nvarying float v_age;\nvarying float v_energy;\nvarying float v_alpha;\nvarying float v_type;\nvarying vec3 v_color;\n\nuniform float u_time;\nuniform float u_mutation;\n\nvoid main() {\n    vec2 coord = gl_PointCoord - vec2(0.5);\n    float dist = length(coord);\n    \n    float circle = smoothstep(0.5, 0.3, dist);\n    float pulse = sin(u_time * 4.0 + v_energy * 10.0) * 0.3 + 0.7;\n    \n    vec3 color = v_color * pulse;\n    float alpha = circle * v_alpha;\n    \n    gl_FragColor = vec4(color, alpha);\n}";this.program=s.createProgram(this.gl,t,r)}createBuffers(){this.particleBuffer=this.gl.createBuffer()}emitParticle(e,t,r,n=l.ENERGY){this.particles.length>=this.maxParticles&&this.particles.shift();const i=c.Dm.random()*Math.PI*2,o=this.getSpeedForType(n),a=this.getColorForType(n,r),s=this.getSizeForType(n,r),u={x:e+.02*(c.Dm.random()-.5),y:t+.02*(c.Dm.random()-.5),vx:Math.cos(i)*o,vy:Math.sin(i)*o,energy:r*(.7+.3*c.Dm.random()),age:0,maxAge:this.getMaxAgeForType(n),type:n,size:s,color:a,mutation:n===l.MUTATION};this.particles.push(u)}getSpeedForType(e){switch(e){case l.ENERGY:return.03+.07*c.Dm.random();case l.MUTATION:return.08+.12*c.Dm.random();case l.CONSCIOUSNESS:return.01+.03*c.Dm.random();case l.TRAIT:return.02+.05*c.Dm.random();default:return.05}}getColorForType(e,t){const r=.8+.2*t;switch(e){case l.ENERGY:return[0*r,.878*r,1*r];case l.MUTATION:return[1*r,.2*r,.8*r];case l.CONSCIOUSNESS:return[.9*r,.7*r,.2*r];case l.TRAIT:return[.6*r,.4*r,.9*r];default:return[1,1,1]}}getSizeForType(e,t){const r=.8+.4*t;switch(e){case l.ENERGY:return 1*r;case l.MUTATION:return 1.4*r;case l.CONSCIOUSNESS:return 1.2*r;case l.TRAIT:return.8*r;default:return r}}getMaxAgeForType(e){switch(e){case l.ENERGY:return 2+2*c.Dm.random();case l.MUTATION:return 3+3*c.Dm.random();case l.CONSCIOUSNESS:return 4+4*c.Dm.random();case l.TRAIT:return 1.5+1.5*c.Dm.random();default:return 2}}emitMutationBurst(e,t,r){const n=Math.floor(5+10*r);for(let i=0;i<n;i++)this.emitParticle(e,t,r,l.MUTATION)}emitConsciousnessPulse(e,t,r){const n=Math.floor(3+5*r);for(let i=0;i<n;i++)this.emitParticle(e,t,r,l.CONSCIOUSNESS)}emitTraitParticles(e,t,r){for(const[n,i]of Object.entries(r))i>.3&&c.Dm.random()<i&&this.emitParticle(e,t,i,l.TRAIT)}update(e,t,r,n){for(let t=this.particles.length-1;t>=0;t--){const r=this.particles[t];r.age+=e,r.age>=r.maxAge?this.particles.splice(t,1):(r.x+=r.vx*e,r.y+=r.vy*e)}const i=Date.now()/1e3,o=i-this.lastEmission,a=Math.floor(o*this.emissionRate*t);for(let e=0;e<a;e++){const e=c.Dm.random()*Math.PI*2,i=.1+.2*c.Dm.random(),o=r+Math.cos(e)*i,a=n+Math.sin(e)*i;this.emitParticle(o,a,t)}a>0&&(this.lastEmission=i)}render(e,t,r=0){if(!this.program||0===this.particles.length)return;const n=this.gl,i=[];this.particles.forEach((e=>{i.push(e.x,e.y,e.age,e.energy,e.vx,e.vy,e.type,e.size,e.color[0],e.color[1],e.color[2])})),this.particleBuffer&&(n.bindBuffer(n.ARRAY_BUFFER,this.particleBuffer),n.bufferData(n.ARRAY_BUFFER,new Float32Array(i),n.DYNAMIC_DRAW)),n.enable(n.BLEND),n.blendFunc(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA),n.useProgram(this.program.program);const o=44;let a=0;const l=this.program.attributes.a_position;void 0!==l&&l>=0&&(n.enableVertexAttribArray(l),n.vertexAttribPointer(l,2,n.FLOAT,!1,o,a)),a+=8;const c=this.program.attributes.a_age;void 0!==c&&c>=0&&(n.enableVertexAttribArray(c),n.vertexAttribPointer(c,1,n.FLOAT,!1,o,a)),a+=4;const u=this.program.attributes.a_energy;void 0!==u&&u>=0&&(n.enableVertexAttribArray(u),n.vertexAttribPointer(u,1,n.FLOAT,!1,o,a)),a+=4;const f=this.program.attributes.a_velocity;void 0!==f&&f>=0&&(n.enableVertexAttribArray(f),n.vertexAttribPointer(f,2,n.FLOAT,!1,o,a)),a+=8;const m=this.program.attributes.a_type;void 0!==m&&m>=0&&(n.enableVertexAttribArray(m),n.vertexAttribPointer(m,1,n.FLOAT,!1,o,a)),a+=4;const d=this.program.attributes.a_size;void 0!==d&&d>=0&&(n.enableVertexAttribArray(d),n.vertexAttribPointer(d,1,n.FLOAT,!1,o,a)),a+=4;const h=this.program.attributes.a_color;void 0!==h&&h>=0&&(n.enableVertexAttribArray(h),n.vertexAttribPointer(h,3,n.FLOAT,!1,o,a)),s.setUniform1f(n,this.program.uniforms.u_time,e),s.setUniform1f(n,this.program.uniforms.u_globalEnergy,t),s.setUniform1f(n,this.program.uniforms.u_mutation,r),this.program.uniforms.u_resolution&&n.uniform2f(this.program.uniforms.u_resolution,n.canvas.width,n.canvas.height);const v=n.isEnabled(n.DEPTH_TEST);v&&n.disable(n.DEPTH_TEST),n.drawArrays(n.POINTS,0,this.particles.length),v&&n.enable(n.DEPTH_TEST),void 0!==l&&l>=0&&n.disableVertexAttribArray(l),void 0!==c&&c>=0&&n.disableVertexAttribArray(c),void 0!==u&&u>=0&&n.disableVertexAttribArray(u),void 0!==f&&f>=0&&n.disableVertexAttribArray(f),void 0!==m&&m>=0&&n.disableVertexAttribArray(m),void 0!==d&&d>=0&&n.disableVertexAttribArray(d),void 0!==h&&h>=0&&n.disableVertexAttribArray(h)}destroy(){this.gl&&this.program&&this.gl.deleteProgram(this.program.program),this.gl&&this.particleBuffer&&this.gl.deleteBuffer(this.particleBuffer),this.particles=[]}};var f=r(72),m=r.n(f),d=r(825),h=r.n(d),v=r(659),g=r.n(v),_=r(56),p=r.n(_),y=r(159),A=r.n(y),b=r(113),x=r.n(b),E=r(967),T={};async function R(e){try{const t=await fetch(e);if(!t.ok)throw new Error(`Failed to load shader: ${t.statusText}`);return await t.text()}catch(t){throw a.vF.error(`Failed to load shader ${e}:`,t),t}}T.styleTagTransform=x(),T.setAttributes=p(),T.insert=g().bind(null,"head"),T.domAPI=h(),T.insertStyleElement=A(),m()(E.A,T),E.A&&E.A.locals&&E.A.locals;const F="\nprecision highp float;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nuniform float u_time;\nuniform float u_complexity;\nuniform float u_fluidity;\nuniform float u_consciousness;\nuniform mat3 u_transform;\nuniform float u_curiosity;\nuniform float u_focus;\nuniform float u_rhythm;\nuniform float u_empathy;\nuniform float u_creativity;\nvarying vec2 v_texCoord;\nvarying vec2 v_position;\nvarying float v_pattern;\nvarying float v_energy;\nvarying float v_consciousness;\n\nfloat noise(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main() {\n    v_texCoord = a_texCoord;\n    v_position = a_position;\n    vec2 pos = a_position;\n    float fluidEffect = sin(u_time * u_rhythm + pos.x * u_empathy) * u_fluidity;\n    pos.x += fluidEffect * 0.1;\n    v_pattern = noise(pos * 2.0 + u_time * 0.1);\n    v_energy = (1.0 - length(pos)) * u_consciousness;\n    v_consciousness = u_consciousness;\n    vec3 worldPos = u_transform * vec3(pos, 1.0);\n    gl_Position = vec4(worldPos.xy, 0.0, 1.0);\n}",w="\nprecision highp float;\n#define TEX texture2D\nvarying vec2 v_texCoord;\nvarying vec2 v_position;\nvarying float v_pattern;\nvarying float v_energy;\nvarying float v_consciousness;\nuniform float u_time;\nuniform float u_mutation;\nuniform vec3 u_primaryColor;\nuniform vec3 u_secondaryColor;\nuniform vec3 u_accentColor;\nuniform sampler2D u_noiseTexture;\nuniform float u_curiosity;\nuniform float u_focus;\nuniform float u_rhythm;\nuniform float u_empathy;\nuniform float u_creativity;\n\nvoid main() {\n    float distanceFromCenter = length(v_position);\n    vec2 noiseCoord = v_texCoord + u_time * 0.05;\n    float noise1 = TEX(u_noiseTexture, noiseCoord).r;\n    float organicPattern = v_pattern + noise1 * 0.3;\n    vec3 baseColor = mix(u_primaryColor, u_secondaryColor, organicPattern);\n    float consciousnessGlow = v_consciousness * exp(-distanceFromCenter * 2.0);\n    baseColor = mix(baseColor, u_accentColor, consciousnessGlow * 0.4);\n    float alpha = smoothstep(1.0, 0.7, distanceFromCenter) * (0.8 + v_energy * 0.2);\n    gl_FragColor = vec4(baseColor, alpha * 0.9);\n}",C=({width:e=400,height:t=300,className:r=""})=>{const l=(0,i.useRef)(null),c=(0,i.useRef)(null),f=(0,i.useRef)(null),m=(0,i.useRef)(null),d=(0,i.useRef)(null),h=(0,i.useRef)(null),v=(0,i.useRef)(null),g=(0,i.useRef)(Date.now()),_=(0,i.useRef)(Date.now()),p=(0,i.useRef)(!1),y=(0,i.useRef)(60),A=(0,i.useRef)(16.67),{organism:b}=(0,o.YT)(),[x,E]=(0,i.useState)(!1),[T,C]=(0,i.useState)(null);return(0,i.useEffect)((()=>{const e=()=>{const e=document.hidden?10:b&&b.energy&&b.energy<30?30:b&&b.energy&&b.energy<60?45:60;e!==y.current&&(y.current=e,A.current=1e3/e,a.vF.info(`WebGL FPS adaptatif: ${e} FPS`))},t=setInterval(e,2e3),r=()=>{e()};return document.addEventListener("visibilitychange",r),()=>{clearInterval(t),document.removeEventListener("visibilitychange",r)}}),[b?.energy]),(0,i.useEffect)((()=>{const e=l.current;if(!e)return;const t=e=>{e.preventDefault(),p.current=!0,C("WebGL context lost - attempting recovery..."),a.vF.warn("WebGL context lost")},r=()=>{p.current=!1,C(null),a.vF.info("WebGL context restored"),n()};e.addEventListener("webglcontextlost",t),e.addEventListener("webglcontextrestored",r);const n=async()=>{let t=null;try{if(!window.WebGLRenderingContext)throw new Error("WebGL not available in this browser");t=setTimeout((()=>{C("WebGL initialization timeout - switching to 2D fallback"),a.vF.warn("WebGL initialization timeout")}),5e3);const r={alpha:!0,depth:!1,stencil:!1,antialias:!0,premultipliedAlpha:!1,preserveDrawingBuffer:!1,powerPreference:"default",failIfMajorPerformanceCaveat:!1};let n,i,o=null,l=!1;try{if(o=e.getContext("webgl2",r),o){const e=o.getSupportedExtensions()||[];l=!0,a.vF.info("WebGL2 context acquired with extensions:",e)}}catch(e){a.vF.warn("WebGL2 initialization failed:",e)}if(!o)try{o=e.getContext("webgl",r),o&&a.vF.info("Falling back to WebGL1")}catch(e){a.vF.warn("WebGL1 initialization failed:",e)}if(!o)try{o=e.getContext("experimental-webgl",r),o&&a.vF.warn("Using experimental WebGL context")}catch(e){a.vF.error("All WebGL contexts failed:",e)}if(!o)throw new Error("WebGL not supported - falling back to minimal 2D renderer");c.current=o;try{l?(a.vF.info("Loading WebGL2 enhanced shaders"),n=await R(chrome?.runtime?.getURL?chrome.runtime.getURL("shaders/enhanced-organism.vert"):"/src/shaders/enhanced-organism.vert"),i=await R(chrome?.runtime?.getURL?chrome.runtime.getURL("shaders/enhanced-organism.frag"):"/src/shaders/enhanced-organism.frag")):(a.vF.info("Using WebGL1 fallback shaders"),n=F,i=w)}catch(e){a.vF.warn("Failed to load enhanced shaders, using fallback:",e),n=F,i=w}const v=s.createProgram(o,n,i);if(!v)throw new Error("Failed to create shader program");f.current=v;const g=s.createCircleMesh(o,64);if(!g)throw new Error("Failed to create mesh");m.current=g;const _=s.generateNoiseTexture(o,256);if(!_)throw new Error("Failed to create noise texture");d.current=_;const p=new u(o,150);h.current=p,o.enable(o.BLEND),o.blendFunc(o.SRC_ALPHA,o.ONE_MINUS_SRC_ALPHA),o.clearColor(0,0,0,0),t&&clearTimeout(t),E(!0),a.vF.info("WebGL Organism Viewer initialized successfully")}catch(e){t&&clearTimeout(t);const r=e instanceof Error?e.message:"Unknown WebGL error";C(r),a.vF.error("WebGL initialization failed:",r)}};return n(),()=>{e.removeEventListener("webglcontextlost",t),e.removeEventListener("webglcontextrestored",r)}}),[]),(0,i.useEffect)((()=>{if(!x||!b||!c.current||!f.current||!m.current||p.current)return;const r=c.current,n=f.current,i=m.current,o=l.current,a=h.current,u=()=>{if(!(o&&r&&n&&i))return;const l=Date.now(),c=(l-_.current)/1e3;if(c<A.current/1e3)return void(v.current=requestAnimationFrame(u));_.current=l;const f=window.devicePixelRatio||1,m=e,h=t,p=Math.floor(m*f),y=Math.floor(h*f);o.width===p&&o.height===y||(o.width=p,o.height=y,o.className="webgl-canvas webgl-canvas-resized"),r.viewport(0,0,o.width,o.height),r.clear(r.COLOR_BUFFER_BIT),r.useProgram(n.program),r.bindBuffer(r.ARRAY_BUFFER,i.vertexBuffer),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,i.indexBuffer);const x=n.attributes.a_position,E=n.attributes.a_texCoord;void 0!==x&&x>=0&&(r.enableVertexAttribArray(x),r.vertexAttribPointer(x,2,r.FLOAT,!1,16,0)),void 0!==E&&E>=0&&(r.enableVertexAttribArray(E),r.vertexAttribPointer(E,2,r.FLOAT,!1,16,8));const T=(Date.now()-g.current)/1e3,R=b.traits||{curiosity:.5,focus:.5,rhythm:.5,empathy:.5,creativity:.5},F=new Float32Array([1,0,0,0,1,0,0,0,1]),w=.8+.4*R.creativity,C=T*R.rhythm*.1,S=Math.cos(C),U=Math.sin(C);F[0]=S*w,F[1]=-U*w,F[3]=U*w,F[4]=S*w,n.uniforms.u_time&&s.setUniform1f(r,n.uniforms.u_time,T),n.uniforms.u_complexity&&s.setUniform1f(r,n.uniforms.u_complexity,.7+.3*R.creativity),n.uniforms.u_fluidity&&s.setUniform1f(r,n.uniforms.u_fluidity,.4+.6*R.empathy),n.uniforms.u_consciousness&&s.setUniform1f(r,n.uniforms.u_consciousness,b.consciousness||.5),n.uniforms.u_energy&&s.setUniform1f(r,n.uniforms.u_energy,(b.energy||50)/100),n.uniforms.u_mutation&&s.setUniform1f(r,n.uniforms.u_mutation,.1+.01*(b.generation||0)),n.uniforms.u_transform&&s.setUniformMatrix3(r,n.uniforms.u_transform,F),n.uniforms.u_resolution&&r.uniform2f(n.uniforms.u_resolution,o.width,o.height),n.uniforms.u_curiosity&&s.setUniform1f(r,n.uniforms.u_curiosity,R.curiosity),n.uniforms.u_focus&&s.setUniform1f(r,n.uniforms.u_focus,R.focus),n.uniforms.u_rhythm&&s.setUniform1f(r,n.uniforms.u_rhythm,Math.max(.1,R.rhythm)),n.uniforms.u_empathy&&s.setUniform1f(r,n.uniforms.u_empathy,R.empathy),n.uniforms.u_creativity&&s.setUniform1f(r,n.uniforms.u_creativity,R.creativity);const N=[0+.3*R.curiosity,.878-.2*R.focus,1-.3*R.empathy],P=[.373+.2*R.creativity,.765+.1*R.rhythm,.969-.1*R.focus],B=[.612+.3*R.empathy,.416+.2*R.curiosity,.875-.1*R.creativity];if(n.uniforms.u_primaryColor&&s.setUniform3f(r,n.uniforms.u_primaryColor,N[0],N[1],N[2]),n.uniforms.u_secondaryColor&&s.setUniform3f(r,n.uniforms.u_secondaryColor,P[0],P[1],P[2]),n.uniforms.u_accentColor&&s.setUniform3f(r,n.uniforms.u_accentColor,B[0],B[1],B[2]),d.current&&n.uniforms.u_noiseTexture&&(r.activeTexture(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,d.current),r.uniform1i(n.uniforms.u_noiseTexture,0)),r.drawElements(r.TRIANGLES,i.vertexCount,r.UNSIGNED_SHORT,0),a){const e=(b.energy||50)/100;a.update(c,e,0,0),a.render(T,e)}v.current=requestAnimationFrame(u)};return u(),()=>{v.current&&cancelAnimationFrame(v.current)}}),[x,b,e,t]),(0,i.useEffect)((()=>()=>{v.current&&cancelAnimationFrame(v.current),h.current&&h.current.destroy();const e=c.current;e&&f.current&&e.deleteProgram(f.current.program),e&&m.current&&(e.deleteBuffer(m.current.vertexBuffer),e.deleteBuffer(m.current.indexBuffer)),e&&d.current&&e.deleteTexture(d.current)}),[]),T?(0,n.jsx)("div",{className:`webgl-error ${r}`,children:(0,n.jsxs)("div",{className:"error-content",children:[(0,n.jsx)("div",{className:"error-icon",children:"‚ö†Ô∏è"}),(0,n.jsxs)("div",{className:"error-message",children:["WebGL Error: ",T]}),(0,n.jsx)("div",{className:"error-hint",children:"Your browser may not support WebGL"})]})}):b?(0,n.jsxs)("div",{className:`webgl-organism-viewer ${r}`,children:[(0,n.jsx)("canvas",{ref:l,width:e,height:t,className:"webgl-canvas"}),(0,n.jsxs)("div",{className:"organism-info-overlay",children:[(0,n.jsxs)("div",{className:"info-item",children:[(0,n.jsx)("span",{children:"Gen"}),(0,n.jsx)("span",{children:b.generation})]}),(0,n.jsxs)("div",{className:"info-item",children:[(0,n.jsx)("span",{children:"ADN"}),(0,n.jsxs)("span",{children:[b.dna?.substring(0,6),"..."]})]}),(0,n.jsxs)("div",{className:"info-item",children:[(0,n.jsx)("span",{children:"√ânergie"}),(0,n.jsx)("span",{children:Math.round(b.energy||0)})]})]})]}):(0,n.jsxs)("div",{className:`organism-loading ${r}`,children:[(0,n.jsx)("div",{className:"loading-spinner",children:"üß¨"}),(0,n.jsx)("div",{children:"Loading organism..."})]})},S=C},967:(e,t,r)=>{r.d(t,{A:()=>s});var n=r(601),i=r.n(n),o=r(314),a=r.n(o)()(i());a.push([e.id,"/* Styles WebGL - Conformit√© CSP */\n\n.webgl-canvas {\n  width: 100%;\n  height: 100%;\n  display: block;\n}\n\n.webgl-canvas-resized {\n  /* Canvas size handled programmatically via width/height attributes */\n}\n\n.webgl-organism-viewer {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n\n.organism-info-overlay {\n  position: absolute;\n  top: 16px;\n  right: 16px;\n  background: rgba(10, 13, 21, 0.85);\n  -webkit-backdrop-filter: blur(12px);\n          backdrop-filter: blur(12px);\n  border: 1px solid rgba(0, 224, 255, 0.2);\n  border-radius: 12px;\n  padding: 16px;\n  min-width: 160px;\n  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);\n}\n\n.webgl-error {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  min-height: 200px;\n  background: #1a1a1a;\n  border-radius: 8px;\n  color: #ff6b6b;\n  text-align: center;\n}\n\n.organism-loading {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  min-height: 200px;\n  background: #1a1a1a;\n  border-radius: 8px;\n  color: #00e0ff;\n  text-align: center;\n}",""]);const s=a}}]);