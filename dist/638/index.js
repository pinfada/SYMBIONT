"use strict";(self.webpackChunksymbiont=self.webpackChunksymbiont||[]).push([[638],{638:(e,r,t)=>{t.r(r),t.d(r,{WebGLOrganismViewer:()=>c,default:()=>f});var n=t(848),i=t(540),o=t(23),a=t(513);const s=class{static createShader(e,r,t){const n=e.createShader(r);if(!n)return a.vF.error("Failed to create shader"),null;if(e.shaderSource(n,t),e.compileShader(n),!e.getShaderParameter(n,e.COMPILE_STATUS)){const r=e.getShaderInfoLog(n);return a.vF.error("Shader compilation error:",r),e.deleteShader(n),null}return n}static createProgram(e,r,t){const n=this.createShader(e,e.VERTEX_SHADER,r),i=this.createShader(e,e.FRAGMENT_SHADER,t);if(!n||!i)return null;const o=e.createProgram();if(!o)return a.vF.error("Failed to create shader program"),null;if(e.attachShader(o,n),e.attachShader(o,i),e.linkProgram(o),!e.getProgramParameter(o,e.LINK_STATUS)){const r=e.getProgramInfoLog(o);return a.vF.error("Program linking error:",r),e.deleteProgram(o),null}const s={},u={},l=e.getProgramParameter(o,e.ACTIVE_UNIFORMS);for(let r=0;r<l;r++){const t=e.getActiveUniform(o,r);t&&(s[t.name]=e.getUniformLocation(o,t.name))}const c=e.getProgramParameter(o,e.ACTIVE_ATTRIBUTES);for(let r=0;r<c;r++){const t=e.getActiveAttrib(o,r);t&&(u[t.name]=e.getAttribLocation(o,t.name))}return e.deleteShader(n),e.deleteShader(i),{program:o,uniforms:s,attributes:u}}static createBuffer(e,r,t=e.STATIC_DRAW){const n=e.createBuffer();return n?(e.bindBuffer(e.ARRAY_BUFFER,n),e.bufferData(e.ARRAY_BUFFER,r,t),e.bindBuffer(e.ARRAY_BUFFER,null),n):(a.vF.error("Failed to create buffer"),null)}static createIndexBuffer(e,r,t=e.STATIC_DRAW){const n=e.createBuffer();return n?(e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n),e.bufferData(e.ELEMENT_ARRAY_BUFFER,r,t),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),n):(a.vF.error("Failed to create index buffer"),null)}static createQuadMesh(e){const r=new Float32Array([-1,-1,0,0,1,-1,1,0,1,1,1,1,-1,1,0,1]),t=new Uint16Array([0,1,2,0,2,3]),n=this.createBuffer(e,r),i=this.createIndexBuffer(e,t);return n&&i?{vertexBuffer:n,indexBuffer:i,vertexCount:t.length}:null}static createCircleMesh(e,r=32){const t=[],n=[];t.push(0,0,.5,.5);for(let e=0;e<=r;e++){const n=e/r*Math.PI*2,i=Math.cos(n),o=Math.sin(n),a=.5*(i+1),s=.5*(o+1);t.push(i,o,a,s)}for(let e=1;e<=r;e++)n.push(0,e,e+1);n.push(0,r+1,1);const i=this.createBuffer(e,new Float32Array(t)),o=this.createIndexBuffer(e,new Uint16Array(n));return i&&o?{vertexBuffer:i,indexBuffer:o,vertexCount:n.length}:null}static setUniform1f(e,r,t){null!=r&&e.uniform1f(r,t)}static setUniform3f(e,r,t,n,i){null!=r&&e.uniform3f(r,t,n,i)}static setUniformMatrix3(e,r,t){null!=r&&e.uniformMatrix3fv(r,!1,t)}static createTexture(e,r,t,n){const i=e.createTexture();return i?(e.bindTexture(e.TEXTURE_2D,i),n?e.texImage2D(e.TEXTURE_2D,0,e.RGBA,r,t,0,e.RGBA,e.UNSIGNED_BYTE,n):e.texImage2D(e.TEXTURE_2D,0,e.RGBA,r,t,0,e.RGBA,e.UNSIGNED_BYTE,null),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.bindTexture(e.TEXTURE_2D,null),i):(a.vF.error("Failed to create texture"),null)}static generateNoiseTexture(e,r=256){const t=new Uint8Array(r*r*4);for(let e=0;e<r*r;e++){const r=Math.random();t[4*e]=255*r,t[4*e+1]=255*r,t[4*e+2]=255*r,t[4*e+3]=255}return this.createTexture(e,r,r,t)}static resizeCanvas(e,r,t){const n=r||e.clientWidth,i=t||e.clientHeight;return(e.width!==n||e.height!==i)&&(e.width=n,e.height=i,!0)}};var u=t(18);const l=class{constructor(e,r=100){this.program=null,this.particles=[],this.particleBuffer=null,this.lastEmission=0,this.gl=e,this.maxParticles=r,this.emissionRate=20,this.initializeShaders(),this.createBuffers()}initializeShaders(){this.program=s.createProgram(this.gl,"precision highp float;\n\nattribute vec2 a_position;\nattribute float a_age;\nattribute float a_energy;\nattribute vec2 a_velocity;\n\nuniform float u_time;\nuniform float u_globalEnergy;\nuniform vec2 u_resolution;\n\nvarying float v_age;\nvarying float v_energy;\nvarying float v_alpha;\n\nfloat noise(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main() {\n    vec2 pos = a_position;\n    \n    float lifetime = 3.0;\n    float normalizedAge = a_age / lifetime;\n    \n    // Mouvement des particules\n    vec2 drift = a_velocity * a_age;\n    pos += drift;\n    \n    // Oscillation\n    float oscillation = sin(u_time * 2.0 + pos.x * 10.0) * 0.02;\n    pos.y += oscillation * (1.0 - normalizedAge);\n    \n    // Attraction vers le centre\n    vec2 toCenter = -normalize(pos) * u_globalEnergy * 0.1;\n    pos += toCenter * normalizedAge;\n    \n    float size = a_energy * (1.0 - normalizedAge * 0.7) * 8.0;\n    \n    v_alpha = (1.0 - normalizedAge) * a_energy;\n    v_age = normalizedAge;\n    v_energy = a_energy;\n    \n    gl_Position = vec4(pos, 0.0, 1.0);\n    gl_PointSize = size;\n}","precision highp float;\n\nvarying float v_age;\nvarying float v_energy;\nvarying float v_alpha;\n\nuniform float u_time;\nuniform vec3 u_energyColor;\nuniform vec3 u_coreColor;\n\nvoid main() {\n    vec2 coord = gl_PointCoord - vec2(0.5);\n    float dist = length(coord);\n    \n    float circle = smoothstep(0.5, 0.3, dist);\n    float halo = smoothstep(0.5, 0.0, dist);\n    \n    float pulse = sin(u_time * 4.0 + v_energy * 10.0) * 0.3 + 0.7;\n    \n    vec3 color = mix(u_coreColor, u_energyColor, v_age);\n    color *= pulse;\n    \n    float twinkle = fract(sin(v_energy * 123.456) * 43758.5453);\n    twinkle = step(0.97, twinkle) * 2.0;\n    color += vec3(twinkle * 0.5);\n    \n    float alpha = circle * v_alpha * (0.8 + halo * 0.2);\n    \n    gl_FragColor = vec4(color, alpha);\n}")}createBuffers(){this.particleBuffer=this.gl.createBuffer()}emitParticle(e,r,t){this.particles.length>=this.maxParticles&&this.particles.shift();const n=u.Dm.random()*Math.PI*2,i=.05+.1*u.Dm.random(),o={x:e,y:r,vx:Math.cos(n)*i,vy:Math.sin(n)*i,energy:t*(.5+.5*u.Dm.random()),age:0,maxAge:2+2*u.Dm.random()};this.particles.push(o)}update(e,r,t,n){for(let r=this.particles.length-1;r>=0;r--){const t=this.particles[r];t.age+=e,t.age>=t.maxAge?this.particles.splice(r,1):(t.x+=t.vx*e,t.y+=t.vy*e)}const i=Date.now()/1e3,o=i-this.lastEmission,a=Math.floor(o*this.emissionRate*r);for(let e=0;e<a;e++){const e=u.Dm.random()*Math.PI*2,i=.1+.2*u.Dm.random(),o=t+Math.cos(e)*i,a=n+Math.sin(e)*i;this.emitParticle(o,a,r)}a>0&&(this.lastEmission=i)}render(e,r){if(!this.program||0===this.particles.length)return;const t=this.gl,n=[];this.particles.forEach((e=>{n.push(e.x,e.y,e.age,e.energy,e.vx,e.vy)})),this.particleBuffer&&(t.bindBuffer(t.ARRAY_BUFFER,this.particleBuffer),t.bufferData(t.ARRAY_BUFFER,new Float32Array(n),t.DYNAMIC_DRAW)),t.useProgram(this.program.program);const i=this.program.attributes.a_position,o=this.program.attributes.a_age,a=this.program.attributes.a_energy,u=this.program.attributes.a_velocity;void 0!==i&&i>=0&&(t.enableVertexAttribArray(i),t.vertexAttribPointer(i,2,t.FLOAT,!1,24,0)),void 0!==o&&o>=0&&(t.enableVertexAttribArray(o),t.vertexAttribPointer(o,1,t.FLOAT,!1,24,8)),void 0!==a&&a>=0&&(t.enableVertexAttribArray(a),t.vertexAttribPointer(a,1,t.FLOAT,!1,24,12)),void 0!==u&&u>=0&&(t.enableVertexAttribArray(u),t.vertexAttribPointer(u,2,t.FLOAT,!1,24,16)),s.setUniform1f(t,this.program.uniforms.u_time,e),s.setUniform1f(t,this.program.uniforms.u_globalEnergy,r),s.setUniform3f(t,this.program.uniforms.u_energyColor,0,.878,1),s.setUniform3f(t,this.program.uniforms.u_coreColor,1,1,1),t.drawArrays(t.POINTS,0,this.particles.length)}destroy(){this.gl&&this.program&&this.gl.deleteProgram(this.program.program),this.gl&&this.particleBuffer&&this.gl.deleteBuffer(this.particleBuffer),this.particles=[]}},c=({width:e=400,height:r=300,className:t=""})=>{const u=(0,i.useRef)(null),c=(0,i.useRef)(null),f=(0,i.useRef)(null),m=(0,i.useRef)(null),h=(0,i.useRef)(null),d=(0,i.useRef)(null),g=(0,i.useRef)(null),v=(0,i.useRef)(Date.now()),_=(0,i.useRef)(Date.now()),p=(0,i.useRef)(!1),y=(0,i.useRef)(60),x=(0,i.useRef)(16.67),{organism:b}=(0,o.YT)(),[E,A]=(0,i.useState)(!1),[R,T]=(0,i.useState)(null);return(0,i.useEffect)((()=>{const e=()=>{const e=document.hidden?10:b&&b.energy&&b.energy<30?30:b&&b.energy&&b.energy<60?45:60;e!==y.current&&(y.current=e,x.current=1e3/e,a.vF.info(`WebGL FPS adaptatif: ${e} FPS`))},r=setInterval(e,2e3),t=()=>{e()};return document.addEventListener("visibilitychange",t),()=>{clearInterval(r),document.removeEventListener("visibilitychange",t)}}),[b?.energy]),(0,i.useEffect)((()=>{const e=u.current;if(!e)return;const r=e=>{e.preventDefault(),p.current=!0,T("WebGL context lost - attempting recovery..."),a.vF.warn("WebGL context lost")},t=()=>{p.current=!1,T(null),a.vF.info("WebGL context restored"),n()};e.addEventListener("webglcontextlost",r),e.addEventListener("webglcontextrestored",t);const n=()=>{try{if(!window.WebGLRenderingContext)throw new Error("WebGL not available in this browser");const r={alpha:!0,depth:!1,stencil:!1,antialias:!0,premultipliedAlpha:!1,preserveDrawingBuffer:!1,powerPreference:"default",failIfMajorPerformanceCaveat:!1};let t=e.getContext("webgl2",r);if(t||(t=e.getContext("webgl",r)),t||(t=e.getContext("experimental-webgl",r)),!t)throw new Error("WebGL not supported in this browser");c.current=t;const n=s.createProgram(t,"\nprecision highp float;\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\n\nuniform float u_time;\nuniform float u_complexity;\nuniform float u_fluidity;\nuniform float u_consciousness;\nuniform vec2 u_resolution;\n\n// Traits de l'organisme\nuniform float u_curiosity;\nuniform float u_focus;\nuniform float u_rhythm;\nuniform float u_empathy;\nuniform float u_creativity;\n\nvarying vec2 v_texCoord;\nvarying vec2 v_position;\nvarying float v_pattern;\nvarying float v_energy;\nvarying float v_consciousness;\n\n// Fonction de bruit optimis√©e\nfloat noise(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Bruit fractal bas√© sur les traits\nfloat fractalNoise(vec2 p, float complexity) {\n    float value = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    \n    for (int i = 0; i < 4; i++) {\n        value += amplitude * noise(p * frequency);\n        amplitude *= 0.5;\n        frequency *= 2.0 + complexity * u_creativity;\n    }\n    \n    return value;\n}\n\nvoid main() {\n    v_texCoord = a_texCoord;\n    v_position = a_position;\n    \n    // D√©formation bas√©e sur les traits\n    vec2 pos = a_position;\n    \n    // Effet de fluidit√© bas√© sur empathy et rhythm\n    float fluidEffect = sin(u_time * u_rhythm + pos.x * u_empathy) * u_fluidity;\n    pos.x += fluidEffect * 0.1;\n    \n    // D√©formation de curiosit√© (exploration spatiale)\n    float curiosityWave = sin(u_time * 0.5 + length(pos) * u_curiosity * 5.0) * 0.05;\n    pos += normalize(pos) * curiosityWave;\n    \n    // Focus affecte la stabilit√© (moins de d√©formation si focus √©lev√©)\n    float focusStability = 1.0 - u_focus * 0.3;\n    float instability = noise(pos + u_time * 0.1) * focusStability * 0.02;\n    pos += vec2(instability, instability * 0.7);\n    \n    // Pattern fractal pour la surface\n    v_pattern = fractalNoise(pos * 2.0 + u_time * 0.1, u_complexity);\n    \n    // √ânergie bas√©e sur la distance au centre et la conscience\n    float distanceFromCenter = length(pos);\n    v_energy = (1.0 - distanceFromCenter) * u_consciousness;\n    v_consciousness = u_consciousness;\n    \n    gl_Position = vec4(pos, 0.0, 1.0);\n}","\nprecision highp float;\n\n// Macro pour compatibilit√© WebGL1\n#define TEX texture2D\n\nvarying vec2 v_texCoord;\nvarying vec2 v_position;\nvarying float v_pattern;\nvarying float v_energy;\nvarying float v_consciousness;\n\nuniform float u_time;\nuniform float u_mutation;\nuniform float u_energy;\nuniform vec3 u_primaryColor;\nuniform vec3 u_secondaryColor;\nuniform vec3 u_accentColor;\nuniform sampler2D u_noiseTexture;\nuniform vec2 u_resolution;\n\n// Traits pour influencer l'apparence\nuniform float u_curiosity;\nuniform float u_focus;\nuniform float u_rhythm;\nuniform float u_empathy;\nuniform float u_creativity;\n\n// Conversion HSV vers RGB\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Fonction de m√©lange de couleurs bas√©e sur les traits\nvec3 traitColorMix(vec3 base, float pattern) {\n    // Curiosity affecte la variance des couleurs\n    float hueShift = u_curiosity * sin(u_time * 0.5 + v_position.x * 10.0) * 0.1;\n    \n    // Creativity influence la saturation\n    float saturation = 0.6 + u_creativity * 0.4;\n    \n    // Focus affecte la coh√©rence (moins de variations si focus √©lev√©)\n    float coherence = u_focus;\n    \n    // Empathy influence la chaleur des couleurs\n    vec3 warmShift = vec3(u_empathy * 0.2, 0.0, -u_empathy * 0.1);\n    \n    // Rhythm cr√©e des pulsations de couleur\n    float rhythmPulse = sin(u_time * u_rhythm * 2.0) * 0.1 + 1.0;\n    \n    vec3 color = mix(u_primaryColor, u_secondaryColor, pattern);\n    color += warmShift;\n    color *= rhythmPulse;\n    \n    // Conversion en HSV pour manipulation\n    float hue = atan(color.y, color.x) / (2.0 * 3.14159) + 0.5 + hueShift;\n    vec3 hsv = vec3(hue, saturation, 0.8 + pattern * 0.2);\n    \n    return hsv2rgb(hsv);\n}\n\nvoid main() {\n    // Distance du centre pour les effets radiaux\n    float distanceFromCenter = length(v_position);\n    \n    // Pattern organique complexe\n    vec2 noiseCoord = v_texCoord + u_time * 0.05;\n    float noise1 = TEX(u_noiseTexture, noiseCoord).r;\n    \n    float organicPattern = v_pattern + noise1 * 0.3;\n    organicPattern += sin(distanceFromCenter * 8.0 + u_time * 2.0) * 0.1;\n    \n    // Couleur de base bas√©e sur les traits\n    vec3 baseColor = traitColorMix(u_primaryColor, organicPattern);\n    \n    // Effet de conscience (halo central)\n    float consciousnessGlow = v_consciousness * exp(-distanceFromCenter * 2.0);\n    consciousnessGlow *= (1.0 + sin(u_time * 3.0) * 0.3);\n    \n    // M√©lange avec couleur d'accent pour la conscience\n    baseColor = mix(baseColor, u_accentColor, consciousnessGlow * 0.4);\n    \n    // Effet d'√©nergie (pulsation)\n    float energyPulse = v_energy * (0.8 + 0.2 * sin(u_time * 4.0));\n    baseColor *= (0.7 + energyPulse * 0.3);\n    \n    // Effet de mutation (inversion partielle)\n    if (u_mutation > 0.1) {\n        float mutationMask = noise1;\n        if (mutationMask > (1.0 - u_mutation)) {\n            baseColor = vec3(1.0) - baseColor * 0.8;\n        }\n    }\n    \n    // √âclairage proc√©dural\n    vec3 lightDir = normalize(vec3(cos(u_time * 0.5), sin(u_time * 0.5), 0.5));\n    vec3 normal = normalize(vec3(v_position, sqrt(max(0.0, 1.0 - dot(v_position, v_position)))));\n    float lighting = max(0.3, dot(normal, lightDir));\n    \n    baseColor *= lighting;\n    \n    // Effet de bord (rim lighting)\n    float rimEffect = 1.0 - distanceFromCenter;\n    rimEffect = pow(rimEffect, 2.0);\n    baseColor += u_accentColor * rimEffect * 0.2;\n    \n    // Transparence bas√©e sur la distance et l'√©nergie\n    float alpha = smoothstep(1.0, 0.7, distanceFromCenter);\n    alpha *= (0.8 + v_energy * 0.2);\n    \n    // Anti-aliasing doux\n    alpha *= smoothstep(0.0, 0.02, organicPattern);\n    \n    gl_FragColor = vec4(baseColor, alpha * 0.9);\n}");if(!n)throw new Error("Failed to create shader program");f.current=n;const i=s.createCircleMesh(t,64);if(!i)throw new Error("Failed to create mesh");m.current=i;const o=s.generateNoiseTexture(t,256);if(!o)throw new Error("Failed to create noise texture");h.current=o;const u=new l(t,150);d.current=u,t.enable(t.BLEND),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA),t.clearColor(0,0,0,0),A(!0),a.vF.info("WebGL Organism Viewer initialized successfully")}catch(e){const r=e instanceof Error?e.message:"Unknown WebGL error";T(r),a.vF.error("WebGL initialization failed:",r)}};return n(),()=>{e.removeEventListener("webglcontextlost",r),e.removeEventListener("webglcontextrestored",t)}}),[]),(0,i.useEffect)((()=>{if(!(E&&b&&c.current&&f.current&&m.current))return;const t=c.current,n=f.current,i=m.current,o=u.current,a=d.current,l=()=>{if(!(o&&t&&n&&i))return;const u=Date.now(),c=(u-_.current)/1e3;if(c<x.current/1e3)return void(g.current=requestAnimationFrame(l));_.current=u;const f=window.devicePixelRatio||1,m=e,d=r,p=Math.floor(m*f),y=Math.floor(d*f);o.width===p&&o.height===y||(o.width=p,o.height=y,o.style.width=m+"px",o.style.height=d+"px"),t.viewport(0,0,o.width,o.height),t.clear(t.COLOR_BUFFER_BIT),t.useProgram(n.program),t.bindBuffer(t.ARRAY_BUFFER,i.vertexBuffer),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,i.indexBuffer);const E=n.attributes.a_position,A=n.attributes.a_texCoord;void 0!==E&&E>=0&&(t.enableVertexAttribArray(E),t.vertexAttribPointer(E,2,t.FLOAT,!1,16,0)),void 0!==A&&A>=0&&(t.enableVertexAttribArray(A),t.vertexAttribPointer(A,2,t.FLOAT,!1,16,8));const R=(Date.now()-v.current)/1e3,T=b.traits||{curiosity:.5,focus:.5,rhythm:.5,empathy:.5,creativity:.5};if(n.uniforms.u_time&&s.setUniform1f(t,n.uniforms.u_time,R),n.uniforms.u_complexity&&s.setUniform1f(t,n.uniforms.u_complexity,.8),n.uniforms.u_fluidity&&s.setUniform1f(t,n.uniforms.u_fluidity,.6),n.uniforms.u_consciousness&&s.setUniform1f(t,n.uniforms.u_consciousness,b.consciousness||.5),n.uniforms.u_energy&&s.setUniform1f(t,n.uniforms.u_energy,(b.energy||50)/100),n.uniforms.u_mutation&&s.setUniform1f(t,n.uniforms.u_mutation,.2),n.uniforms.u_resolution&&t.uniform2f(n.uniforms.u_resolution,o.width,o.height),n.uniforms.u_curiosity&&s.setUniform1f(t,n.uniforms.u_curiosity,T.curiosity),n.uniforms.u_focus&&s.setUniform1f(t,n.uniforms.u_focus,T.focus),n.uniforms.u_rhythm&&s.setUniform1f(t,n.uniforms.u_rhythm,T.rhythm),n.uniforms.u_empathy&&s.setUniform1f(t,n.uniforms.u_empathy,T.empathy),n.uniforms.u_creativity&&s.setUniform1f(t,n.uniforms.u_creativity,T.creativity),n.uniforms.u_primaryColor&&s.setUniform3f(t,n.uniforms.u_primaryColor,0,.878,1),n.uniforms.u_secondaryColor&&s.setUniform3f(t,n.uniforms.u_secondaryColor,.373,.765,.969),n.uniforms.u_accentColor&&s.setUniform3f(t,n.uniforms.u_accentColor,.612,.416,.875),h.current&&n.uniforms.u_noiseTexture&&(t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,h.current),t.uniform1i(n.uniforms.u_noiseTexture,0)),t.drawElements(t.TRIANGLES,i.vertexCount,t.UNSIGNED_SHORT,0),a){const e=(b.energy||50)/100;a.update(c,e,0,0),a.render(R,e)}g.current=requestAnimationFrame(l)};return l(),()=>{g.current&&cancelAnimationFrame(g.current)}}),[E,b,e,r]),(0,i.useEffect)((()=>()=>{g.current&&cancelAnimationFrame(g.current),d.current&&d.current.destroy();const e=c.current;e&&f.current&&e.deleteProgram(f.current.program),e&&m.current&&(e.deleteBuffer(m.current.vertexBuffer),e.deleteBuffer(m.current.indexBuffer)),e&&h.current&&e.deleteTexture(h.current)}),[]),R?(0,n.jsx)("div",{className:`webgl-error ${t}`,children:(0,n.jsxs)("div",{className:"error-content",children:[(0,n.jsx)("div",{className:"error-icon",children:"‚ö†Ô∏è"}),(0,n.jsxs)("div",{className:"error-message",children:["WebGL Error: ",R]}),(0,n.jsx)("div",{className:"error-hint",children:"Your browser may not support WebGL"})]})}):b?(0,n.jsxs)("div",{className:`webgl-organism-viewer ${t}`,children:[(0,n.jsx)("canvas",{ref:u,width:e,height:r,style:{width:"100%",height:"100%",display:"block"}}),(0,n.jsxs)("div",{className:"organism-info-overlay",children:[(0,n.jsxs)("div",{className:"info-item",children:[(0,n.jsx)("span",{children:"Gen"}),(0,n.jsx)("span",{children:b.generation})]}),(0,n.jsxs)("div",{className:"info-item",children:[(0,n.jsx)("span",{children:"ADN"}),(0,n.jsxs)("span",{children:[b.dna?.substring(0,6),"..."]})]}),(0,n.jsxs)("div",{className:"info-item",children:[(0,n.jsx)("span",{children:"√ânergie"}),(0,n.jsx)("span",{children:Math.round(b.energy||0)})]})]})]}):(0,n.jsxs)("div",{className:`organism-loading ${t}`,children:[(0,n.jsx)("div",{className:"loading-spinner",children:"üß¨"}),(0,n.jsx)("div",{children:"Loading organism..."})]})},f=c}}]);