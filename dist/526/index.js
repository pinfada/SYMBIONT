"use strict";(self.webpackChunksymbiont=self.webpackChunksymbiont||[]).push([[526],{526:(e,t,o)=>{o.d(t,{p:()=>n});class n{constructor(){this.db=null,this.DB_NAME="symbiont-db",this.DB_VERSION=3,this.OPERATION_TIMEOUT=1e4,this.MAX_STORAGE_SIZE_MB=50,this.quotaWarningIssued=!1}withTimeout(e,t=this.OPERATION_TIMEOUT){return Promise.race([e,new Promise(((e,o)=>setTimeout((()=>o(new Error(`Operation timed out after ${t}ms`))),t)))])}async initialize(){if("undefined"==typeof indexedDB)throw new Error("IndexedDB is not available in this environment");console.log("[SymbiontStorage] Starting initialization...",{dbName:this.DB_NAME,dbVersion:this.DB_VERSION});const e=this.db;if(e){console.log("[SymbiontStorage] Closing existing database connection");try{e.close()}catch(e){console.warn("[SymbiontStorage] Error closing existing connection:",e)}this.db=null}try{const e=this.checkStorageQuota();await Promise.race([e,new Promise(((e,t)=>setTimeout((()=>t(new Error("Storage quota check timeout"))),3e3)))])}catch(e){console.warn("[SymbiontStorage] Failed to check storage quota (continuing anyway):",e)}let t=null;for(let e=1;e<=3;e++)try{return console.log(`[SymbiontStorage] Initialization attempt ${e}/3`),await this.attemptInitialize(3===e),void console.log("[SymbiontStorage] Initialization completed successfully")}catch(o){if(t=o instanceof Error?o:new Error(String(o)),console.error(`[SymbiontStorage] Initialization attempt ${e} failed:`,t),!(e<3&&(t.message.includes("blocked")||t.message.includes("timeout"))))break;{const o=t.message.includes("blocked")?2e3*e:1e3*e;console.log(`[SymbiontStorage] Waiting ${o}ms before retry (blocked: ${t.message.includes("blocked")})...`),await new Promise((e=>setTimeout(e,o)));const n=this.db;if(n){try{n.close()}catch(e){console.warn("[SymbiontStorage] Error closing connection before retry:",e)}this.db=null}if(t.message.includes("blocked")&&2===e){console.warn("[SymbiontStorage] Attempting to force close blocked database...");try{await this.forceCloseDatabase()}catch(e){console.warn("[SymbiontStorage] Could not force close database:",e)}}}}console.error("[SymbiontStorage] All initialization attempts failed");const o=this.db;if(o){try{o.close()}catch(e){console.error("[SymbiontStorage] Error closing database after failed init:",e)}this.db=null}throw t||new Error("IndexedDB initialization failed after all retries")}attemptInitialize(e){return new Promise(((t,o)=>{let n=null,r=!1,s=null;const a=()=>{n&&(clearTimeout(n),n=null),s&&(clearTimeout(s),s=null)},i=e=>{r||(r=!0,a(),o(e))},c=e?2e4:1e4;n=setTimeout((()=>{console.error(`[SymbiontStorage] IndexedDB open request timeout (no response after ${c}ms)`),i(new Error(`IndexedDB open request timeout - no response from browser after ${c}ms`))}),c),console.log("[SymbiontStorage] Opening IndexedDB...");const l=indexedDB.open(this.DB_NAME,this.DB_VERSION);l.onerror=()=>{const e=l.error;console.error("[SymbiontStorage] IndexedDB open failed:",{name:e?.name,message:e?.message,code:e?.code}),i(e||new Error("Unknown IndexedDB error"))},l.onsuccess=()=>{console.log("[SymbiontStorage] IndexedDB opened successfully");try{if(this.db=l.result,!this.db)return void i(new Error("IndexedDB opened but result is null"));this.db.onerror=e=>{console.error("[SymbiontStorage] Database error:",e)},this.db.onversionchange=()=>{console.warn("[SymbiontStorage] Database version changed, closing connection"),this.db?.close(),this.db=null},console.log("[SymbiontStorage] Database initialized successfully",{objectStores:Array.from(this.db.objectStoreNames)}),r||(r=!0,a(),t())}catch(e){console.error("[SymbiontStorage] Error setting up database:",e),i(e instanceof Error?e:new Error("Unknown error during database setup"))}},l.onupgradeneeded=e=>{console.log("[SymbiontStorage] Database upgrade needed");try{const t=e.target.result;if(!t)return void console.error("[SymbiontStorage] Database upgrade: result is null");if(!t.objectStoreNames.contains("organisms")){console.log("[SymbiontStorage] Creating organisms store");const e=t.createObjectStore("organisms",{keyPath:"id"});e.createIndex("generation","generation",{unique:!1}),e.createIndex("createdAt","createdAt",{unique:!1})}if(!t.objectStoreNames.contains("behaviors")){console.log("[SymbiontStorage] Creating behaviors store");const e=t.createObjectStore("behaviors",{keyPath:"url"});e.createIndex("lastVisit","lastVisit",{unique:!1}),e.createIndex("visitCount","visitCount",{unique:!1})}if(!t.objectStoreNames.contains("mutations")){console.log("[SymbiontStorage] Creating mutations store");const e=t.createObjectStore("mutations",{keyPath:"id",autoIncrement:!0});e.createIndex("timestamp","timestamp",{unique:!1}),e.createIndex("type","type",{unique:!1})}if(t.objectStoreNames.contains("settings")||(console.log("[SymbiontStorage] Creating settings store"),t.createObjectStore("settings",{keyPath:"key"})),!t.objectStoreNames.contains("invitations")){console.log("[SymbiontStorage] Creating invitations store");const e=t.createObjectStore("invitations",{keyPath:"code"});e.createIndex("createdAt","createdAt",{unique:!1}),e.createIndex("status","status",{unique:!1})}console.log("[SymbiontStorage] Database upgrade completed")}catch(e){console.error("[SymbiontStorage] Error during database upgrade:",e),i(e instanceof Error?e:new Error("Unknown error during database upgrade"))}},l.onblocked=()=>{if(console.warn("[SymbiontStorage] IndexedDB open blocked - another connection is open"),console.warn("[SymbiontStorage] Waiting for other connection to close..."),s&&clearTimeout(s),n){clearTimeout(n);const t=e?3e4:2e4;n=setTimeout((()=>{console.error(`[SymbiontStorage] IndexedDB still blocked after ${t}ms wait`),console.error("[SymbiontStorage] This usually means another tab/context has the database open"),i(new Error(`IndexedDB blocked - another connection preventing access after ${t}ms`))}),t)}}}))}async getOrganism(e){if(!this.db)throw new Error("Database not initialized");const t=new Promise(((t,o)=>{const n=this.db.transaction(["organisms"],"readonly").objectStore("organisms");if(e){const r=n.get(e);r.onsuccess=()=>t(r.result||null),r.onerror=()=>o(r.error)}else{const e=n.openCursor();e.onsuccess=e=>{const o=e.target.result;t(o?o.value:null)},e.onerror=()=>o(e.error)}}));return this.withTimeout(t)}async saveOrganism(e){if(!this.db)throw new Error("Database not initialized");const t=new Promise(((t,o)=>{const n=this.db.transaction(["organisms"],"readwrite").objectStore("organisms").put(e);n.onsuccess=()=>t(),n.onerror=()=>o(n.error)}));return this.withTimeout(t)}async getBehavior(e){if(!this.db)throw new Error("Database not initialized");return new Promise(((t,o)=>{const n=this.db.transaction(["behaviors"],"readonly").objectStore("behaviors").get(e);n.onsuccess=()=>t(n.result||null),n.onerror=()=>o(n.error)}))}async saveBehavior(e){if(!this.db)throw new Error("Database not initialized");return new Promise(((t,o)=>{const n=this.db.transaction(["behaviors"],"readwrite").objectStore("behaviors").put(e);n.onsuccess=()=>t(),n.onerror=()=>o(n.error)}))}async addMutation(e){if(!this.db)throw new Error("Database not initialized");const t={...e,timestamp:e.timestamp||Date.now()};return new Promise(((e,o)=>{const n=this.db.transaction(["mutations"],"readwrite").objectStore("mutations").add(t);n.onsuccess=()=>e(),n.onerror=()=>o(n.error)}))}async getRecentMutations(e=10){if(!this.db)throw new Error("Database not initialized");return new Promise(((t,o)=>{const n=this.db.transaction(["mutations"],"readonly").objectStore("mutations").index("timestamp").openCursor(null,"prev"),r=[];n.onsuccess=o=>{const n=o.target.result;n&&r.length<e?(r.push(n.value),n.continue()):t(r)},n.onerror=()=>o(n.error)}))}async getSetting(e,t){if(!this.db)throw new Error("Database not initialized");return new Promise(((o,n)=>{const r=this.db.transaction(["settings"],"readonly").objectStore("settings").get(e);r.onsuccess=()=>{const e=r.result;o(e?e.value:t)},r.onerror=()=>n(r.error)}))}async setSetting(e,t){if(!this.db)throw new Error("Database not initialized");return new Promise(((o,n)=>{const r=this.db.transaction(["settings"],"readwrite").objectStore("settings").put({key:e,value:t});r.onsuccess=()=>o(),r.onerror=()=>n(r.error)}))}async addInvitation(e){if(!this.db)throw new Error("Database not initialized");return new Promise(((t,o)=>{const n=this.db.transaction(["invitations"],"readwrite").objectStore("invitations").add({...e,createdAt:e.createdAt||Date.now()});n.onsuccess=()=>t(),n.onerror=()=>o(n.error)}))}async updateInvitation(e){if(!this.db)throw new Error("Database not initialized");return new Promise(((t,o)=>{const n=this.db.transaction(["invitations"],"readwrite").objectStore("invitations").put(e);n.onsuccess=()=>t(),n.onerror=()=>o(n.error)}))}async getInvitation(e){if(!this.db)throw new Error("Database not initialized");return new Promise(((t,o)=>{const n=this.db.transaction(["invitations"],"readonly").objectStore("invitations").get(e);n.onsuccess=()=>t(n.result||null),n.onerror=()=>o(n.error)}))}async getAllInvitations(){if(!this.db)throw new Error("Database not initialized");return new Promise(((e,t)=>{const o=this.db.transaction(["invitations"],"readonly").objectStore("invitations").openCursor(),n=[];o.onsuccess=t=>{const o=t.target.result;o?(n.push(o.value),o.continue()):e(n)},o.onerror=()=>t(o.error)}))}async getBehaviorPatterns(){if(!this.db)throw new Error("Database not initialized");return new Promise(((e,t)=>{const o=this.db.transaction(["behaviors"],"readonly").objectStore("behaviors").openCursor(),n=[];o.onsuccess=t=>{const o=t.target.result;o?(n.push(o.value),o.continue()):(n.sort(((e,t)=>t.visitCount!==e.visitCount?t.visitCount-e.visitCount:t.lastVisit-e.lastVisit)),e(n))},o.onerror=()=>t(o.error)}))}async getRecentActivity(e=864e5){if(!this.db)throw new Error("Database not initialized");const t=Date.now()-e;return new Promise(((e,o)=>{const n=this.db.transaction(["behaviors"],"readonly").objectStore("behaviors").openCursor(),r=[];n.onsuccess=o=>{const n=o.target.result;if(n){const e=n.value,o=(e.interactions||[]).filter((e=>e.timestamp>=t));for(const t of o)r.push({...t,url:e.url});n.continue()}else r.sort(((e,t)=>t.timestamp-e.timestamp)),e(r)},n.onerror=()=>o(n.error)}))}async cleanup(e=30){if(!this.db)throw new Error("Database not initialized");const t=Date.now()-24*e*60*60*1e3;return new Promise(((e,o)=>{const n=this.db.transaction(["mutations"],"readwrite").objectStore("mutations").index("timestamp"),r=IDBKeyRange.upperBound(t),s=n.openCursor(r);s.onsuccess=t=>{const o=t.target.result;o?(o.delete(),o.continue()):e()},s.onerror=()=>o(s.error)}))}async checkStorageQuota(){if(navigator.storage&&navigator.storage.estimate)try{const e=await navigator.storage.estimate(),t=(e.usage||0)/1048576,o=(e.quota||0)/1048576,n=o>0?t/o*100:0;console.info("Storage quota:",{usageInMB:t.toFixed(2),quotaInMB:o.toFixed(2),usagePercent:n.toFixed(2)+"%"}),n>80&&!this.quotaWarningIssued&&(this.quotaWarningIssued=!0,console.warn("STORAGE WARNING: Usage above 80%, consider cleanup"),n>90&&(console.warn("STORAGE CRITICAL: Usage above 90%, triggering automatic cleanup"),await this.cleanup(15))),t>.9*this.MAX_STORAGE_SIZE_MB&&(console.error("STORAGE CRITICAL: Approaching maximum storage size limit"),await this.cleanup(7))}catch(e){console.error("Failed to check storage quota:",e)}else console.warn("Storage API not available, skipping quota check")}async getStorageStats(){if(!navigator.storage||!navigator.storage.estimate)return{usageInMB:0,quotaInMB:0,usagePercent:0,needsCleanup:!1};try{const e=await navigator.storage.estimate(),t=(e.usage||0)/1048576,o=(e.quota||0)/1048576,n=o>0?t/o*100:0;return{usageInMB:t,quotaInMB:o,usagePercent:n,needsCleanup:n>80}}catch(e){return console.error("Failed to get storage stats:",e),{usageInMB:0,quotaInMB:0,usagePercent:0,needsCleanup:!1}}}close(){const e=this.db;e&&(e.close(),this.db=null)}async forceCloseDatabase(){console.warn("[SymbiontStorage] Attempting to force close database by deleting and recreating...");const e=this.db;if(e){try{e.close()}catch(e){console.warn("[SymbiontStorage] Error closing our connection:",e)}this.db=null}return await new Promise((e=>setTimeout(e,1e3))),new Promise((e=>{const t=indexedDB.deleteDatabase(this.DB_NAME);t.onsuccess=()=>{console.log("[SymbiontStorage] Database deleted successfully, will be recreated on next open"),e()},t.onerror=()=>{const o=t.error;console.warn("[SymbiontStorage] Could not delete database:",o),e()},t.onblocked=()=>{console.warn("[SymbiontStorage] Database delete blocked - another connection still open"),setTimeout((()=>{setTimeout((()=>{console.warn("[SymbiontStorage] Database delete still blocked, giving up"),e()}),5e3)}),1e3)}}))}}}}]);