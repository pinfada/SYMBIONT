{"file":"/mnt/c/Users/m_oli/Projets/SYMBIONT/src/core/NeuralMeshAsync.ts","mappings":"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","names":[],"sources":["/mnt/c/Users/m_oli/Projets/SYMBIONT/src/core/NeuralMeshAsync.ts"],"sourcesContent":["// Version asynchrone de NeuralMesh utilisant Web Workers\r\n// Décharge les calculs intensifs vers un thread séparé\r\n\r\nimport { INeuralMesh } from './interfaces/INeuralMesh';\r\nimport { WorkerMessage, WorkerResponse } from '../workers/NeuralWorker';\r\nimport { errorHandler } from './utils/ErrorHandler';\r\n\r\ninterface NeuralNode {\r\n  id: string;\r\n  type: 'input' | 'hidden' | 'output';\r\n  activation: number;\r\n  bias: number;\r\n}\r\n\r\ninterface NeuralConnection {\r\n  from: string;\r\n  to: string;\r\n  weight: number;\r\n  active: boolean;\r\n}\r\n\r\ninterface NeuralMeshAsyncConfig {\r\n  useWorker?: boolean;\r\n  fallbackToMainThread?: boolean;\r\n  maxRetries?: number;\r\n  timeoutMs?: number;\r\n}\r\n\r\nexport class NeuralMeshAsync implements INeuralMesh {\r\n  private nodes: Map<string, NeuralNode> = new Map();\r\n  private connections: Map<string, NeuralConnection[]> = new Map();\r\n  private activations: Map<string, number> = new Map();\r\n  // @ts-expect-error Taux réservé pour usage futur\r\n  private learningRate: number = 0.01;\r\n  \r\n  // Worker management\r\n  private worker: Worker | null = null;\r\n  private networkId: string;\r\n  private workerReady = false;\r\n  private pendingOperations = new Map<string, {\r\n    resolve: (value: any) => void;\r\n    reject: (error: Error) => void;\r\n    timeout: NodeJS.Timeout;\r\n  }>();\r\n\r\n  // Performance tracking\r\n  private lastPropagationTime = 0;\r\n  private averageProcessingTime = 0;\r\n  private operationCount = 0;\r\n\r\n  // @ts-expect-error Configuration réservée pour usage futur\r\n  private config: any;\r\n\r\n  constructor(config: NeuralMeshAsyncConfig = {}) {\r\n    this.config = {\r\n      useWorker: true,\r\n      fallbackToMainThread: true,\r\n      maxRetries: 3,\r\n      timeoutMs: 5000,\r\n      ...config\r\n    };\r\n    this.networkId = `network_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n    this.initializeWorker();\r\n  }\r\n\r\n  /**\r\n   * Initialise le Web Worker\r\n   */\r\n  private initializeWorker(): void {\r\n    try {\r\n      // Dans un environnement de navigateur, nous devons créer le worker différemment\r\n      const workerBlob = new Blob([\r\n        // Contenu du worker en tant que string (pour contourner les limitations)\r\n        `\r\n        // Worker code sera injecté ici lors du build\r\n        importScripts('./workers/NeuralWorker.js');\r\n        `\r\n      ], { type: 'application/javascript' });\r\n      \r\n      this.worker = new Worker(URL.createObjectURL(workerBlob));\r\n      this.worker.onmessage = this.handleWorkerMessage.bind(this);\r\n      this.worker.onerror = this.handleWorkerError.bind(this);\r\n      \r\n    } catch (error) {\r\n      errorHandler.logSimpleError('NeuralMeshAsync', 'initializeWorker', error, 'warning');\r\n      // Fallback : mode synchrone\r\n      this.worker = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gère les messages du worker\r\n   */\r\n  private handleWorkerMessage(event: MessageEvent<WorkerResponse>): void {\r\n    const { type, id, payload, processingTime } = event.data;\r\n    \r\n    const operation = this.pendingOperations.get(id);\r\n    if (!operation) {\r\n      errorHandler.logSimpleError('NeuralMeshAsync', 'handleWorkerMessage', \r\n        `Unknown operation ID: ${id}`, 'warning');\r\n      return;\r\n    }\r\n\r\n    // Clear timeout et remove operation\r\n    clearTimeout(operation.timeout);\r\n    this.pendingOperations.delete(id);\r\n\r\n    // Update performance metrics\r\n    this.updatePerformanceMetrics(processingTime);\r\n\r\n    if (type === 'NEURAL_RESULT') {\r\n      operation.resolve(payload);\r\n    } else if (type === 'NEURAL_ERROR') {\r\n      operation.reject(new Error(payload.message));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gère les erreurs du worker\r\n   */\r\n  private handleWorkerError(event: ErrorEvent): void {\r\n    errorHandler.logSimpleError('NeuralMeshAsync', 'handleWorkerError', \r\n      `Worker error: ${event.message}`, 'error');\r\n    \r\n    // Reject all pending operations\r\n    this.pendingOperations.forEach(({ reject, timeout }) => {\r\n      clearTimeout(timeout);\r\n      reject(new Error('Worker error occurred'));\r\n    });\r\n    this.pendingOperations.clear();\r\n  }\r\n\r\n  /**\r\n   * Envoie un message au worker avec timeout\r\n   */\r\n  private sendWorkerMessage<T>(\r\n    type: WorkerMessage['type'], \r\n    payload: any, \r\n    timeoutMs: number = 5000\r\n  ): Promise<T> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.worker) {\r\n        reject(new Error('Worker not available, using fallback'));\r\n        return;\r\n      }\r\n\r\n      const id = `${type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n      \r\n      const timeout = setTimeout(() => {\r\n        this.pendingOperations.delete(id);\r\n        reject(new Error(`Worker operation timeout: ${type}`));\r\n      }, timeoutMs);\r\n\r\n      this.pendingOperations.set(id, { resolve, reject, timeout });\r\n\r\n      const message: WorkerMessage = { type, id, payload };\r\n      this.worker.postMessage(message);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Met à jour les métriques de performance\r\n   */\r\n  private updatePerformanceMetrics(processingTime: number): void {\r\n    this.operationCount++;\r\n    this.lastPropagationTime = processingTime;\r\n    \r\n    // Moving average\r\n    const weight = 0.1;\r\n    this.averageProcessingTime = this.averageProcessingTime * (1 - weight) + processingTime * weight;\r\n  }\r\n\r\n  /**\r\n   * Ajoute un nœud au réseau\r\n   */\r\n  addNode(id: string, type: 'input' | 'hidden' | 'output', bias: number = 0): void {\r\n    const node: NeuralNode = { id, type, activation: 0, bias };\r\n    this.nodes.set(id, node);\r\n    this.activations.set(id, 0);\r\n  }\r\n\r\n  /**\r\n   * Ajoute une connexion entre deux nœuds\r\n   */\r\n  addConnection(fromId: string, toId: string, weight: number): void {\r\n    if (!this.nodes.has(fromId) || !this.nodes.has(toId)) {\r\n      throw new Error(`Cannot connect non-existent nodes: ${fromId} -> ${toId}`);\r\n    }\r\n\r\n    const connection: NeuralConnection = { from: fromId, to: toId, weight, active: true };\r\n\r\n    if (!this.connections.has(fromId)) {\r\n      this.connections.set(fromId, []);\r\n    }\r\n    this.connections.get(fromId)!.push(connection);\r\n  }\r\n\r\n  /**\r\n   * Stimule un nœud d'entrée\r\n   */\r\n  stimulate(nodeId: string, value: number): void {\r\n    const node = this.nodes.get(nodeId);\r\n    if (!node || node.type !== 'input') {\r\n      errorHandler.logSimpleError('NeuralMeshAsync', 'stimulate', \r\n        `Cannot stimulate non-input node: ${nodeId}`, 'warning');\r\n      return;\r\n    }\r\n    this.activations.set(nodeId, value);\r\n  }\r\n\r\n  /**\r\n   * Propagation des signaux dans le réseau\r\n   */\r\n  async propagate(): Promise<void> {\r\n    const startTime = performance.now();\r\n    \r\n    errorHandler.safeExecute(\r\n      () => {\r\n        // Increment operation count\r\n        this.operationCount++;\r\n        \r\n        // Try worker first if available\r\n        if (this.worker && this.workerReady) {\r\n          this.sendWorkerMessage('NEURAL_PROPAGATE', {\r\n            networkId: this.networkId,\r\n            activations: Object.fromEntries(this.activations)\r\n          }).catch(error => {\r\n            errorHandler.logSimpleError('NeuralMeshAsync', 'propagate', error, 'warning');\r\n            // Fallback to sync\r\n            this.propagateSync();\r\n          });\r\n        } else {\r\n          // Fallback to synchronous propagation\r\n          this.propagateSync();\r\n        }\r\n        \r\n        // Update performance metrics\r\n        const processingTime = performance.now() - startTime;\r\n        this.updatePerformanceMetrics(processingTime);\r\n      },\r\n      undefined,\r\n      { component: 'NeuralMeshAsync', method: 'propagate' }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Propagation synchrone (fallback)\r\n   */\r\n  private propagateSync(): void {\r\n    // Reset non-input activations\r\n    for (const [nodeId, node] of this.nodes) {\r\n      if (node.type !== 'input') {\r\n        this.activations.set(nodeId, node.bias);\r\n      }\r\n    }\r\n\r\n    // Propagate through connections\r\n    for (const [fromId, connections] of this.connections) {\r\n      const fromActivation = this.activations.get(fromId) || 0;\r\n      \r\n      for (const connection of connections) {\r\n        if (!connection.active) continue;\r\n        \r\n        const currentActivation = this.activations.get(connection.to) || 0;\r\n        const newActivation = currentActivation + (fromActivation * connection.weight);\r\n        this.activations.set(connection.to, this.sigmoid(newActivation));\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fonction d'activation sigmoïde\r\n   */\r\n  private sigmoid(x: number): number {\r\n    return 1 / (1 + Math.exp(-x));\r\n  }\r\n\r\n  /**\r\n   * Récupère l'activation d'un nœud\r\n   */\r\n  getActivation(nodeId: string): number {\r\n    return this.activations.get(nodeId) || 0;\r\n  }\r\n\r\n  /**\r\n   * Applique une mutation aléatoire au réseau (version async)\r\n   */\r\n  async mutate(rate: number = 0.05): Promise<void> {\r\n    try {\r\n      if (this.worker && this.workerReady) {\r\n        await this.sendWorkerMessage('NEURAL_MUTATE', {\r\n          networkId: this.networkId,\r\n          rate\r\n        });\r\n        \r\n        // Sync back the mutations to local state\r\n        await this.syncNetworkFromWorker();\r\n      } else {\r\n        this.mutateSync(rate);\r\n      }\r\n    } catch (error) {\r\n      errorHandler.logSimpleError('NeuralMeshAsync', 'mutate', error, 'warning');\r\n      this.mutateSync(rate);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mutation synchrone (fallback)\r\n   */\r\n  private mutateSync(rate: number): void {\r\n    // Mutate connection weights\r\n    for (const connections of this.connections.values()) {\r\n      for (const connection of connections) {\r\n        if (Math.random() < rate) {\r\n          connection.weight += (Math.random() - 0.5) * 0.2;\r\n          connection.weight = Math.max(-2, Math.min(2, connection.weight));\r\n        }\r\n      }\r\n    }\r\n\r\n    // Mutate node biases\r\n    for (const node of this.nodes.values()) {\r\n      if (Math.random() < rate) {\r\n        node.bias += (Math.random() - 0.5) * 0.1;\r\n        node.bias = Math.max(-1, Math.min(1, node.bias));\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Synchronise l'état du réseau depuis le worker\r\n   */\r\n  private async syncNetworkFromWorker(): Promise<void> {\r\n    // Implementation would sync worker state back to local state\r\n    // For now, we'll skip this complex synchronization\r\n  }\r\n\r\n  /**\r\n   * Mesure l'activité neurale globale - implémentation unifiée\r\n   */\r\n  getNeuralActivity(): number {\r\n    // Synchronous fallback implementation\r\n    let totalActivity = 0;\r\n    let nodeCount = 0;\r\n\r\n    for (const activation of this.activations.values()) {\r\n      totalActivity += Math.abs(activation);\r\n      nodeCount++;\r\n    }\r\n\r\n    return nodeCount > 0 ? totalActivity / nodeCount : 0;\r\n  }\r\n\r\n  /**\r\n   * Version asynchrone de getNeuralActivity pour calculs avancés\r\n   */\r\n  async getNeuralActivityAsync(): Promise<number> {\r\n    try {\r\n      if (this.worker && this.workerReady) {\r\n        const result = await this.sendWorkerMessage<{\r\n          activity: number;\r\n          connectionStrength: number;\r\n          nodeCount: number;\r\n          connectionCount: number;\r\n        }>('NEURAL_ACTIVITY', { networkId: this.networkId });\r\n        \r\n        return result.activity;\r\n      }\r\n    } catch (error) {\r\n      errorHandler.logSimpleError('NeuralMeshAsync', 'getNeuralActivityAsync', error, 'warning');\r\n    }\r\n\r\n    // Fallback synchrone\r\n    return this.getNeuralActivity();\r\n  }\r\n\r\n  /**\r\n   * Mesure la force moyenne des connexions\r\n   */\r\n  getConnectionStrength(): number {\r\n    let totalWeight = 0;\r\n    let connectionCount = 0;\r\n\r\n    for (const connections of this.connections.values()) {\r\n      for (const connection of connections) {\r\n        if (connection.active) {\r\n          totalWeight += Math.abs(connection.weight);\r\n          connectionCount++;\r\n        }\r\n      }\r\n    }\r\n\r\n    return connectionCount > 0 ? totalWeight / connectionCount : 0;\r\n  }\r\n\r\n  /**\r\n   * Export JSON pour debug/sauvegarde\r\n   */\r\n  toJSON(): any {\r\n    return {\r\n      nodes: Array.from(this.nodes.values()),\r\n      connections: Array.from(this.connections.values()).flat(),\r\n      activations: Object.fromEntries(this.activations),\r\n      performance: {\r\n        lastPropagationTime: this.lastPropagationTime,\r\n        averageProcessingTime: this.averageProcessingTime,\r\n        operationCount: this.operationCount,\r\n        workerReady: this.workerReady\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Initialise le réseau neuronal\r\n   */\r\n  async initialize(): Promise<void> {\r\n    // Setup default network if empty\r\n    if (this.nodes.size === 0) {\r\n      this.setupDefaultNetwork();\r\n    }\r\n\r\n    // Initialize worker network\r\n    if (this.worker) {\r\n      try {\r\n        await this.sendWorkerMessage('NEURAL_INIT', {\r\n          networkId: this.networkId,\r\n          nodes: Array.from(this.nodes.values()),\r\n          connections: Array.from(this.connections.values()).flat()\r\n        });\r\n        this.workerReady = true;\r\n      } catch (error) {\r\n        errorHandler.logSimpleError('NeuralMeshAsync', 'initialize', error, 'warning');\r\n        this.workerReady = false;\r\n      }\r\n    }\r\n    \r\n    // Perform initial propagation\r\n    await this.propagate();\r\n  }\r\n\r\n  /**\r\n   * Configure un réseau par défaut pour les tests\r\n   */\r\n  private setupDefaultNetwork(): void {\r\n    // Add input nodes\r\n    this.addNode('sensory_input', 'input');\r\n    this.addNode('memory_input', 'input');\r\n    \r\n    // Add hidden nodes\r\n    this.addNode('processing_1', 'hidden', 0.1);\r\n    this.addNode('processing_2', 'hidden', -0.1);\r\n    \r\n    // Add output nodes\r\n    this.addNode('motor_output', 'output');\r\n    this.addNode('emotion_output', 'output');\r\n    \r\n    // Connect the network\r\n    this.addConnection('sensory_input', 'processing_1', 0.8);\r\n    this.addConnection('memory_input', 'processing_2', 0.6);\r\n    this.addConnection('processing_1', 'motor_output', 0.9);\r\n    this.addConnection('processing_2', 'emotion_output', 0.7);\r\n    this.addConnection('processing_1', 'processing_2', 0.3);\r\n  }\r\n\r\n  /**\r\n   * Suspend neural processing\r\n   */\r\n  async suspend(): Promise<void> {\r\n    // Clear activations but keep structure\r\n    this.activations.clear();\r\n    \r\n    // Terminate worker if needed\r\n    if (this.worker) {\r\n      this.worker.terminate();\r\n      this.worker = null;\r\n      this.workerReady = false;\r\n    }\r\n    \r\n    console.log('Neural mesh suspended');\r\n  }\r\n\r\n  /**\r\n   * Get CPU usage estimation\r\n   */\r\n  async getCPUUsage(): Promise<number> {\r\n    // Calculate based on processing time and operation frequency\r\n    const baseLoad = this.averageProcessingTime / 16.67; // Compare to 60fps frame time\r\n    return Math.min(1, baseLoad);\r\n  }\r\n\r\n  /**\r\n   * Get memory usage estimation\r\n   */\r\n  async getMemoryUsage(): Promise<number> {\r\n    const localMemory = (this.nodes.size + Array.from(this.connections.values()).length) * 64;\r\n    \r\n    // Add worker memory if available\r\n    let workerMemory = 0;\r\n    if (this.worker && this.workerReady) {\r\n      try {\r\n        // Would get actual worker stats, simplified for now\r\n        workerMemory = localMemory; // Estimate\r\n      } catch (error) {\r\n        // Ignore worker memory calculation error\r\n      }\r\n    }\r\n    \r\n    const totalMemory = localMemory + workerMemory;\r\n    return Math.min(1, totalMemory / (1024 * 1024)); // Convert to MB ratio\r\n  }\r\n\r\n  /**\r\n   * Get performance metrics\r\n   */\r\n  getPerformanceMetrics(): {\r\n    lastPropagationTime: number;\r\n    averageProcessingTime: number;\r\n    operationCount: number;\r\n    workerReady: boolean;\r\n  } {\r\n    return {\r\n      lastPropagationTime: this.lastPropagationTime,\r\n      averageProcessingTime: this.averageProcessingTime,\r\n      operationCount: this.operationCount,\r\n      workerReady: this.workerReady\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Save current state for persistence\r\n   */\r\n  saveState(): any {\r\n    return {\r\n      nodes: Array.from(this.nodes.entries()),\r\n      connections: Array.from(this.connections.entries()).map(([key, connections]) => [\r\n        key,\r\n        connections\r\n      ]),\r\n      activations: Object.fromEntries(this.activations),\r\n      performance: this.getPerformanceMetrics()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Load state from saved data\r\n   */\r\n  loadState(state: any): void {\r\n    if (state.nodes) {\r\n      this.nodes.clear();\r\n      for (const [id, node] of state.nodes) {\r\n        this.nodes.set(id, node as NeuralNode);\r\n      }\r\n    }\r\n    \r\n    if (state.connections) {\r\n      this.connections.clear();\r\n      for (const [fromId, connections] of state.connections) {\r\n        this.connections.set(fromId, connections as NeuralConnection[]);\r\n      }\r\n    }\r\n    \r\n    if (state.activations) {\r\n      this.activations.clear();\r\n      for (const [id, activation] of Object.entries(state.activations)) {\r\n        this.activations.set(id, activation as number);\r\n      }\r\n    }\r\n\r\n    if (state.performance) {\r\n      this.lastPropagationTime = state.performance.lastPropagationTime || 0;\r\n      this.averageProcessingTime = state.performance.averageProcessingTime || 0;\r\n      this.operationCount = state.performance.operationCount || 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset neural mesh to initial state\r\n   */\r\n  reset(): void {\r\n    this.nodes.clear();\r\n    this.connections.clear();\r\n    this.activations.clear();\r\n    this.lastPropagationTime = 0;\r\n    this.averageProcessingTime = 0;\r\n    this.operationCount = 0;\r\n    this.setupDefaultNetwork();\r\n  }\r\n\r\n  /**\r\n   * Health check for neural mesh\r\n   */\r\n  healthCheck(): { healthy: boolean; issues: string[] } {\r\n    const issues: string[] = [];\r\n    \r\n    if (this.nodes.size === 0) {\r\n      issues.push('No nodes in neural mesh');\r\n    }\r\n    \r\n    if (this.connections.size === 0) {\r\n      issues.push('No connections in neural mesh');\r\n    }\r\n\r\n    if (this.pendingOperations.size > 10) {\r\n      issues.push(`Too many pending operations: ${this.pendingOperations.size}`);\r\n    }\r\n\r\n    if (this.worker && !this.workerReady) {\r\n      issues.push('Worker is not ready');\r\n    }\r\n    \r\n    // Check for orphaned nodes\r\n    const connectedNodes = new Set<string>();\r\n    for (const [fromId, connections] of this.connections) {\r\n      connectedNodes.add(fromId);\r\n      for (const connection of connections) {\r\n        connectedNodes.add(connection.to);\r\n      }\r\n    }\r\n    \r\n    const orphanedNodes = Array.from(this.nodes.keys()).filter(\r\n      nodeId => !connectedNodes.has(nodeId)\r\n    );\r\n    \r\n    if (orphanedNodes.length > 0) {\r\n      issues.push(`Orphaned nodes: ${orphanedNodes.join(', ')}`);\r\n    }\r\n    \r\n    return {\r\n      healthy: issues.length === 0,\r\n      issues\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Cleanup resources\r\n   */\r\n  cleanup(): void {\r\n    // Clean up pending operations\r\n    this.pendingOperations.forEach(({ timeout }) => {\r\n      clearTimeout(timeout);\r\n    });\r\n    this.pendingOperations.clear();\r\n\r\n    // Terminate worker\r\n    if (this.worker) {\r\n      this.worker.terminate();\r\n      this.worker = null;\r\n    }\r\n\r\n    // Clear all data\r\n    this.nodes.clear();\r\n    this.connections.clear();\r\n    this.activations.clear();\r\n    this.workerReady = false;\r\n  }\r\n} "],"version":3}