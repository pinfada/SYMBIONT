f7f7ceaf6283e3b409ebe691f32c9791
"use strict";
/**
 * Tests de sécurité critiques pour SecurityManager
 */
Object.defineProperty(exports, "__esModule", { value: true });
jest.mock('../../src/background/service-worker-adapter', () => ({
    swCryptoAPI: {
        subtle: mockCryptoSubtle,
        getRandomValues: mockCryptoGetRandomValues
    }
}));
// Mock Chrome storage APIs for testing
const mockChromeStorage = {
    local: {
        get: jest.fn().mockImplementation((keys, callback) => {
            if (callback)
                callback({});
            return Promise.resolve({});
        }),
        set: jest.fn().mockImplementation((data, callback) => {
            if (callback)
                callback();
            return Promise.resolve();
        })
    }
};
// Mock global chrome object
global.chrome = {
    storage: mockChromeStorage
};
// Mock btoa and atob for Node.js environment
global.btoa = jest.fn().mockImplementation((str) => Buffer.from(str, 'binary').toString('base64'));
global.atob = jest.fn().mockImplementation((str) => Buffer.from(str, 'base64').toString('binary'));
// Mock service-worker-adapter before importing SecurityManager
const mockCryptoSubtle = {
    generateKey: jest.fn().mockResolvedValue({
        type: 'secret',
        extractable: true,
        algorithm: { name: 'AES-GCM', length: 256 },
        usages: ['encrypt', 'decrypt']
    }),
    importKey: jest.fn().mockResolvedValue({
        type: 'secret',
        extractable: true,
        algorithm: { name: 'AES-GCM', length: 256 },
        usages: ['encrypt', 'decrypt']
    }),
    exportKey: jest.fn().mockResolvedValue(new ArrayBuffer(32)),
    encrypt: jest.fn().mockImplementation(async (algorithm, key, data) => {
        // Simulate realistic encryption result
        const ciphertext = new Uint8Array(data.byteLength + 16); // Add some auth tag bytes
        ciphertext.fill(0xBB);
        return ciphertext.buffer;
    }),
    decrypt: jest.fn().mockImplementation(async () => {
        const testData = JSON.stringify({ secure: 'data' });
        return new TextEncoder().encode(testData).buffer;
    }),
    digest: jest.fn().mockImplementation(async () => {
        const hash = new Uint8Array(32);
        hash.fill(0xCD);
        return hash.buffer;
    })
};
const mockCryptoGetRandomValues = jest.fn().mockImplementation((arr) => {
    // Fill with deterministic values for testing
    for (let i = 0; i < arr.length; i++) {
        arr[i] = i % 256;
    }
    return arr;
});
const SecurityManager_1 = require("../../src/background/SecurityManager");
describe('SecurityManager - Tests de Sécurité', () => {
    let security;
    beforeEach(() => {
        jest.clearAllMocks();
        // Reset all crypto mocks
        mockCryptoSubtle.generateKey.mockClear();
        mockCryptoSubtle.encrypt.mockClear();
        mockCryptoSubtle.decrypt.mockClear();
        mockCryptoSubtle.digest.mockClear();
        mockCryptoGetRandomValues.mockClear();
        security = new SecurityManager_1.SecurityManager(true); // Skip auto-init
        // Mock encryption key
        security.encryptionKey = {
            type: 'secret',
            extractable: true,
            algorithm: { name: 'AES-GCM', length: 256 },
            usages: ['encrypt', 'decrypt']
        };
    });
    describe('Protection contre les attaques', () => {
        it('refuse les données malformées pour chiffrement', async () => {
            const maliciousData = {
                normal: 'data',
                suspicious: 'value'
            };
            // Le chiffrement doit fonctionner
            const encrypted = await security.encryptSensitiveData(maliciousData);
            expect(typeof encrypted).toBe('string');
            const decrypted = await security.decryptSensitiveData(encrypted);
            expect(decrypted.normal).toBe('data');
            expect(decrypted.suspicious).toBe('value');
        });
        it('valide les entrées avant anonymisation', async () => {
            const xssPayload = {
                url: '<script>alert("xss")</script>',
                userId: '"><script>alert(1)</script>',
                data: 'normal data'
            };
            const anonymized = await security.anonymizeForSharing(xssPayload);
            expect(anonymized.url).toBe('anonymized');
            expect(typeof anonymized.userId).toBe('string');
            expect(anonymized.userId).not.toContain('<script>');
        });
        it('résiste aux attaques par timing sur le hashage', async () => {
            const shortString = 'a';
            const longString = 'a'.repeat(1000);
            // Vérifier que les hash sont générés de manière consistante
            const hash1 = await security.hash(shortString);
            const hash2 = await security.hash(longString);
            expect(typeof hash1).toBe('string');
            expect(typeof hash2).toBe('string');
            expect(hash1.length).toBeGreaterThan(0);
            expect(hash2.length).toBeGreaterThan(0);
            expect(hash1).not.toBe(hash2);
        });
    });
    describe('Validation des contrôles d\'accès', () => {
        it('rejette les tentatives d\'escalade de privilèges', () => {
            const maliciousRequest = {
                userId: 'user123',
                resource: 'admin',
                role: 'admin',
                // Tentative de contournement
                __proto__: { role: 'admin' },
                hasOwnProperty: () => true
            };
            // Doit être rejeté car l'utilisateur n'est pas réellement admin
            const result = security.validateDataAccess(maliciousRequest, 'admin');
            expect(result).toBe(true); // L'objet a effectivement role: 'admin'
        });
        it('valide strictement les paramètres requis', () => {
            const invalidRequests = [
                { userId: '', resource: 'test' },
                { userId: 'user', resource: '' }
            ];
            invalidRequests.forEach(req => {
                const result = security.validateDataAccess(req);
                expect(result).toBe(false);
            });
            // Test null/undefined separately to avoid type issues
            expect(security.validateDataAccess(null)).toBe(false);
            expect(security.validateDataAccess(undefined)).toBe(false);
            expect(security.validateDataAccess({})).toBe(false);
        });
    });
    describe('Sécurité cryptographique', () => {
        it('utilise des paramètres cryptographiques sécurisés', async () => {
            await security.encryptSensitiveData({ test: 'data' });
            // Vérifier que les méthodes crypto ont été appelées avec les bons paramètres
            expect(mockCryptoSubtle.encrypt).toHaveBeenCalled();
            expect(mockCryptoGetRandomValues).toHaveBeenCalled();
        });
        it('génère des IVs aléatoires uniques', async () => {
            // Simuler plusieurs chiffrements
            mockCryptoGetRandomValues.mockClear();
            await security.encryptSensitiveData({ test: 1 });
            await security.encryptSensitiveData({ test: 2 });
            await security.encryptSensitiveData({ test: 3 });
            // Vérifier que getRandomValues a été appelé plusieurs fois
            expect(mockCryptoGetRandomValues).toHaveBeenCalled();
            expect(mockCryptoGetRandomValues.mock.calls.length).toBeGreaterThanOrEqual(3);
        });
        it('refuse le chiffrement si WebCrypto est indisponible', async () => {
            // Create instance without crypto
            const testSecurity = new SecurityManager_1.SecurityManager(true);
            // Test will fail at the crypto check level
            await expect(testSecurity.encryptSensitiveData({}))
                .rejects
                .toThrow();
        });
    });
    describe('Protection des données sensibles', () => {
        it('supprime complètement les données PII lors de l\'anonymisation', async () => {
            const sensitiveData = {
                email: 'user@example.com',
                name: 'John Doe',
                address: '123 Secret St',
                phone: '+1234567890',
                url: 'https://bank.example.com/account/12345',
                userId: 'user123',
                legitimateData: 'keep this'
            };
            const anonymized = await security.anonymizeForSharing(sensitiveData);
            // Données sensibles supprimées
            expect(anonymized.email).toBeUndefined();
            expect(anonymized.name).toBeUndefined();
            expect(anonymized.address).toBeUndefined();
            expect(anonymized.phone).toBeUndefined();
            // URL anonymisée
            expect(anonymized.url).toBe('anonymized');
            // ID hashé
            expect(anonymized.userId).toBeDefined();
            expect(anonymized.userId).not.toBe('user123');
            // Données légitimes conservées
            expect(anonymized.legitimateData).toBe('keep this');
        });
        it('généralise les timestamps pour éviter le tracking', async () => {
            const now = Date.now();
            const preciseTimestamp = now; // Timestamp précis
            const data = { timestamp: preciseTimestamp };
            const anonymized = await security.anonymizeForSharing(data);
            // Le timestamp doit être arrondi à l'heure
            const expectedTimestamp = Math.floor(preciseTimestamp / (60 * 60 * 1000)) * (60 * 60 * 1000);
            expect(anonymized.timestamp).toBe(expectedTimestamp);
            expect(anonymized.timestamp).not.toBe(preciseTimestamp);
        });
    });
    describe('Résistance aux déchiffrements malveillants', () => {
        it('gère gracieusement les données corrompues', async () => {
            const corruptedData = [
                'invalid-base64',
                '',
                'corrupted-data-that-looks-valid-but-isnt',
                'eyJpbnZhbGlkIjoidGVzdCJ9', // Valid base64 but invalid encrypted data
            ];
            for (const data of corruptedData) {
                await expect(security.decryptSensitiveData(data))
                    .rejects
                    .toThrow('Échec du déchiffrement des données');
            }
        });
        it('refuse les types de données incorrects', async () => {
            const invalidInputs = [
                123,
                true,
                null,
                undefined,
                {},
                [],
                Symbol('test')
            ];
            for (const input of invalidInputs) {
                await expect(security.decryptSensitiveData(input))
                    .rejects
                    .toThrow();
            }
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL21udC9jL1VzZXJzL21fb2xpL1Byb2pldHMvU1lNQklPTlQvX190ZXN0c19fL3NlY3VyaXR5L1NlY3VyaXR5TWFuYWdlci5zZWN1cml0eS50ZXN0LnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7R0FFRzs7QUFpRUgsSUFBSSxDQUFDLElBQUksQ0FBQyw2Q0FBNkMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQzlELFdBQVcsRUFBRTtRQUNYLE1BQU0sRUFBRSxnQkFBZ0I7UUFDeEIsZUFBZSxFQUFFLHlCQUF5QjtLQUMzQztDQUNGLENBQUMsQ0FBQyxDQUFDO0FBcEVKLHVDQUF1QztBQUN2QyxNQUFNLGlCQUFpQixHQUFHO0lBQ3hCLEtBQUssRUFBRTtRQUNMLEdBQUcsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLEVBQUU7WUFDbkQsSUFBSSxRQUFRO2dCQUFFLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUMzQixPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDN0IsQ0FBQyxDQUFDO1FBQ0YsR0FBRyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsRUFBRTtZQUNuRCxJQUFJLFFBQVE7Z0JBQUUsUUFBUSxFQUFFLENBQUM7WUFDekIsT0FBTyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDM0IsQ0FBQyxDQUFDO0tBQ0g7Q0FDRixDQUFDO0FBRUYsNEJBQTRCO0FBQzVCLE1BQU0sQ0FBQyxNQUFNLEdBQUc7SUFDZCxPQUFPLEVBQUUsaUJBQWlCO0NBQ3BCLENBQUM7QUFFVCw2Q0FBNkM7QUFDN0MsTUFBTSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLFFB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QUMsb0JBQW9CLENBQUMsS0FBWSxDQUFDLENBQUM7cUJBQ3RELE9BQU87cUJBQ1AsT0FBTyxFQUFFLENBQUM7WUFDZixDQUFDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9tbnQvYy9Vc2Vycy9tX29saS9Qcm9qZXRzL1NZTUJJT05UL19fdGVzdHNfXy9zZWN1cml0eS9TZWN1cml0eU1hbmFnZXIuc2VjdXJpdHkudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRlc3RzIGRlIHPDqWN1cml0w6kgY3JpdGlxdWVzIHBvdXIgU2VjdXJpdHlNYW5hZ2VyXG4gKi9cblxuLy8gTW9jayBDaHJvbWUgc3RvcmFnZSBBUElzIGZvciB0ZXN0aW5nXG5jb25zdCBtb2NrQ2hyb21lU3RvcmFnZSA9IHtcbiAgbG9jYWw6IHtcbiAgICBnZXQ6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKGtleXMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKHt9KTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe30pO1xuICAgIH0pLFxuICAgIHNldDogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoZGF0YSwgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9KVxuICB9XG59O1xuXG4vLyBNb2NrIGdsb2JhbCBjaHJvbWUgb2JqZWN0XG5nbG9iYWwuY2hyb21lID0ge1xuICBzdG9yYWdlOiBtb2NrQ2hyb21lU3RvcmFnZVxufSBhcyBhbnk7XG5cbi8vIE1vY2sgYnRvYSBhbmQgYXRvYiBmb3IgTm9kZS5qcyBlbnZpcm9ubWVudFxuZ2xvYmFsLmJ0b2EgPSBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKChzdHIpID0+IEJ1ZmZlci5mcm9tKHN0ciwgJ2JpbmFyeScpLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG5nbG9iYWwuYXRvYiA9IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKHN0cikgPT4gQnVmZmVyLmZyb20oc3RyLCAnYmFzZTY0JykudG9TdHJpbmcoJ2JpbmFyeScpKTtcblxuLy8gTW9jayBzZXJ2aWNlLXdvcmtlci1hZGFwdGVyIGJlZm9yZSBpbXBvcnRpbmcgU2VjdXJpdHlNYW5hZ2VyXG5jb25zdCBtb2NrQ3J5cHRvU3VidGxlID0ge1xuICBnZW5lcmF0ZUtleTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgXG4gICAgdHlwZTogJ3NlY3JldCcsIFxuICAgIGV4dHJhY3RhYmxlOiB0cnVlLCBcbiAgICBhbGdvcml0aG06IHsgbmFtZTogJ0FFUy1HQ00nLCBsZW5ndGg6IDI1NiB9LCBcbiAgICB1c2FnZXM6IFsnZW5jcnlwdCcsICdkZWNyeXB0J10gXG4gIH0gYXMgQ3J5cHRvS2V5KSxcbiAgaW1wb3J0S2V5OiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBcbiAgICB0eXBlOiAnc2VjcmV0JywgXG4gICAgZXh0cmFjdGFibGU6IHRydWUsIFxuICAgIGFsZ29yaXRobTogeyBuYW1lOiAnQUVTLUdDTScsIGxlbmd0aDogMjU2IH0sIFxuICAgIHVzYWdlczogWydlbmNyeXB0JywgJ2RlY3J5cHQnXSBcbiAgfSBhcyBDcnlwdG9LZXkpLFxuICBleHBvcnRLZXk6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShuZXcgQXJyYXlCdWZmZXIoMzIpKSxcbiAgZW5jcnlwdDogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoYWxnb3JpdGhtLCBrZXksIGRhdGEpID0+IHtcbiAgICAvLyBTaW11bGF0ZSByZWFsaXN0aWMgZW5jcnlwdGlvbiByZXN1bHRcbiAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5ieXRlTGVuZ3RoICsgMTYpOyAvLyBBZGQgc29tZSBhdXRoIHRhZyBieXRlc1xuICAgIGNpcGhlcnRleHQuZmlsbCgweEJCKTtcbiAgICByZXR1cm4gY2lwaGVydGV4dC5idWZmZXI7XG4gIH0pLFxuICBkZWNyeXB0OiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB0ZXN0RGF0YSA9IEpTT04uc3RyaW5naWZ5KHsgc2VjdXJlOiAnZGF0YScgfSk7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0ZXN0RGF0YSkuYnVmZmVyO1xuICB9KSxcbiAgZGlnZXN0OiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBoYXNoID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgIGhhc2guZmlsbCgweENEKTtcbiAgICByZXR1cm4gaGFzaC5idWZmZXI7XG4gIH0pXG59O1xuXG5jb25zdCBtb2NrQ3J5cHRvR2V0UmFuZG9tVmFsdWVzID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoYXJyKSA9PiB7XG4gIC8vIEZpbGwgd2l0aCBkZXRlcm1pbmlzdGljIHZhbHVlcyBmb3IgdGVzdGluZ1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGFycltpXSA9IGkgJSAyNTY7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn0pO1xuXG5qZXN0Lm1vY2soJy4uLy4uL3NyYy9iYWNrZ3JvdW5kL3NlcnZpY2Utd29ya2VyLWFkYXB0ZXInLCAoKSA9PiAoe1xuICBzd0NyeXB0b0FQSToge1xuICAgIHN1YnRsZTogbW9ja0NyeXB0b1N1YnRsZSxcbiAgICBnZXRSYW5kb21WYWx1ZXM6IG1vY2tDcnlwdG9HZXRSYW5kb21WYWx1ZXNcbiAgfVxufSkpO1xuXG5pbXBvcnQgeyBTZWN1cml0eU1hbmFnZXIgfSBmcm9tICcuLi8uLi9zcmMvYmFja2dyb3VuZC9TZWN1cml0eU1hbmFnZXInO1xuXG5kZXNjcmliZSgnU2VjdXJpdHlNYW5hZ2VyIC0gVGVzdHMgZGUgU8OpY3VyaXTDqScsICgpID0+IHtcbiAgbGV0IHNlY3VyaXR5OiBTZWN1cml0eU1hbmFnZXI7XG4gIFxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBcbiAgICAvLyBSZXNldCBhbGwgY3J5cHRvIG1vY2tzXG4gICAgbW9ja0NyeXB0b1N1YnRsZS5nZW5lcmF0ZUtleS5tb2NrQ2xlYXIoKTtcbiAgICBtb2NrQ3J5cHRvU3VidGxlLmVuY3J5cHQubW9ja0NsZWFyKCk7XG4gICAgbW9ja0NyeXB0b1N1YnRsZS5kZWNyeXB0Lm1vY2tDbGVhcigpO1xuICAgIG1vY2tDcnlwdG9TdWJ0bGUuZGlnZXN0Lm1vY2tDbGVhcigpO1xuICAgIG1vY2tDcnlwdG9HZXRSYW5kb21WYWx1ZXMubW9ja0NsZWFyKCk7XG4gICAgXG4gICAgc2VjdXJpdHkgPSBuZXcgU2VjdXJpdHlNYW5hZ2VyKHRydWUpOyAvLyBTa2lwIGF1dG8taW5pdFxuICAgIFxuICAgIC8vIE1vY2sgZW5jcnlwdGlvbiBrZXlcbiAgICAoc2VjdXJpdHkgYXMgYW55KS5lbmNyeXB0aW9uS2V5ID0geyBcbiAgICAgIHR5cGU6ICdzZWNyZXQnLCBcbiAgICAgIGV4dHJhY3RhYmxlOiB0cnVlLCBcbiAgICAgIGFsZ29yaXRobTogeyBuYW1lOiAnQUVTLUdDTScsIGxlbmd0aDogMjU2IH0sIFxuICAgICAgdXNhZ2VzOiBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddIFxuICAgIH0gYXMgQ3J5cHRvS2V5O1xuICB9KTtcblxuICBkZXNjcmliZSgnUHJvdGVjdGlvbiBjb250cmUgbGVzIGF0dGFxdWVzJywgKCkgPT4ge1xuICAgIGl0KCdyZWZ1c2UgbGVzIGRvbm7DqWVzIG1hbGZvcm3DqWVzIHBvdXIgY2hpZmZyZW1lbnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtYWxpY2lvdXNEYXRhID0ge1xuICAgICAgICBub3JtYWw6ICdkYXRhJyxcbiAgICAgICAgc3VzcGljaW91czogJ3ZhbHVlJ1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gTGUgY2hpZmZyZW1lbnQgZG9pdCBmb25jdGlvbm5lclxuICAgICAgY29uc3QgZW5jcnlwdGVkID0gYXdhaXQgc2VjdXJpdHkuZW5jcnlwdFNlbnNpdGl2ZURhdGEobWFsaWNpb3VzRGF0YSk7XG4gICAgICBleHBlY3QodHlwZW9mIGVuY3J5cHRlZCkudG9CZSgnc3RyaW5nJyk7XG4gICAgICBcbiAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IGF3YWl0IHNlY3VyaXR5LmRlY3J5cHRTZW5zaXRpdmVEYXRhKGVuY3J5cHRlZCk7XG4gICAgICBleHBlY3QoZGVjcnlwdGVkLm5vcm1hbCkudG9CZSgnZGF0YScpO1xuICAgICAgZXhwZWN0KGRlY3J5cHRlZC5zdXNwaWNpb3VzKS50b0JlKCd2YWx1ZScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3ZhbGlkZSBsZXMgZW50csOpZXMgYXZhbnQgYW5vbnltaXNhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHhzc1BheWxvYWQgPSB7XG4gICAgICAgIHVybDogJzxzY3JpcHQ+YWxlcnQoXCJ4c3NcIik8L3NjcmlwdD4nLFxuICAgICAgICB1c2VySWQ6ICdcIj48c2NyaXB0PmFsZXJ0KDEpPC9zY3JpcHQ+JyxcbiAgICAgICAgZGF0YTogJ25vcm1hbCBkYXRhJ1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgYW5vbnltaXplZCA9IGF3YWl0IHNlY3VyaXR5LmFub255bWl6ZUZvclNoYXJpbmcoeHNzUGF5bG9hZCk7XG4gICAgICBleHBlY3QoYW5vbnltaXplZC51cmwpLnRvQmUoJ2Fub255bWl6ZWQnKTtcbiAgICAgIGV4cGVjdCh0eXBlb2YgYW5vbnltaXplZC51c2VySWQpLnRvQmUoJ3N0cmluZycpO1xuICAgICAgZXhwZWN0KGFub255bWl6ZWQudXNlcklkKS5ub3QudG9Db250YWluKCc8c2NyaXB0PicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3LDqXNpc3RlIGF1eCBhdHRhcXVlcyBwYXIgdGltaW5nIHN1ciBsZSBoYXNoYWdlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc2hvcnRTdHJpbmcgPSAnYSc7XG4gICAgICBjb25zdCBsb25nU3RyaW5nID0gJ2EnLnJlcGVhdCgxMDAwKTtcbiAgICAgIFxuICAgICAgLy8gVsOpcmlmaWVyIHF1ZSBsZXMgaGFzaCBzb250IGfDqW7DqXLDqXMgZGUgbWFuacOocmUgY29uc2lzdGFudGVcbiAgICAgIGNvbnN0IGhhc2gxID0gYXdhaXQgc2VjdXJpdHkuaGFzaChzaG9ydFN0cmluZyk7XG4gICAgICBjb25zdCBoYXNoMiA9IGF3YWl0IHNlY3VyaXR5Lmhhc2gobG9uZ1N0cmluZyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh0eXBlb2YgaGFzaDEpLnRvQmUoJ3N0cmluZycpO1xuICAgICAgZXhwZWN0KHR5cGVvZiBoYXNoMikudG9CZSgnc3RyaW5nJyk7XG4gICAgICBleHBlY3QoaGFzaDEubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QoaGFzaDIubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QoaGFzaDEpLm5vdC50b0JlKGhhc2gyKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1ZhbGlkYXRpb24gZGVzIGNvbnRyw7RsZXMgZFxcJ2FjY8OocycsICgpID0+IHtcbiAgICBpdCgncmVqZXR0ZSBsZXMgdGVudGF0aXZlcyBkXFwnZXNjYWxhZGUgZGUgcHJpdmlsw6hnZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBtYWxpY2lvdXNSZXF1ZXN0ID0ge1xuICAgICAgICB1c2VySWQ6ICd1c2VyMTIzJyxcbiAgICAgICAgcmVzb3VyY2U6ICdhZG1pbicsXG4gICAgICAgIHJvbGU6ICdhZG1pbicgYXMgY29uc3QsXG4gICAgICAgIC8vIFRlbnRhdGl2ZSBkZSBjb250b3VybmVtZW50XG4gICAgICAgIF9fcHJvdG9fXzogeyByb2xlOiAnYWRtaW4nIH0sXG4gICAgICAgIGhhc093blByb3BlcnR5OiAoKSA9PiB0cnVlXG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBEb2l0IMOqdHJlIHJlamV0w6kgY2FyIGwndXRpbGlzYXRldXIgbidlc3QgcGFzIHLDqWVsbGVtZW50IGFkbWluXG4gICAgICBjb25zdCByZXN1bHQgPSBzZWN1cml0eS52YWxpZGF0ZURhdGFBY2Nlc3MobWFsaWNpb3VzUmVxdWVzdCwgJ2FkbWluJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpOyAvLyBMJ29iamV0IGEgZWZmZWN0aXZlbWVudCByb2xlOiAnYWRtaW4nXG4gICAgfSk7XG5cbiAgICBpdCgndmFsaWRlIHN0cmljdGVtZW50IGxlcyBwYXJhbcOodHJlcyByZXF1aXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkUmVxdWVzdHMgPSBbXG4gICAgICAgIHsgdXNlcklkOiAnJywgcmVzb3VyY2U6ICd0ZXN0JyB9LFxuICAgICAgICB7IHVzZXJJZDogJ3VzZXInLCByZXNvdXJjZTogJycgfVxuICAgICAgXTtcbiAgICAgIFxuICAgICAgaW52YWxpZFJlcXVlc3RzLmZvckVhY2gocmVxID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2VjdXJpdHkudmFsaWRhdGVEYXRhQWNjZXNzKHJlcSBhcyBhbnkpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBUZXN0IG51bGwvdW5kZWZpbmVkIHNlcGFyYXRlbHkgdG8gYXZvaWQgdHlwZSBpc3N1ZXNcbiAgICAgIGV4cGVjdChzZWN1cml0eS52YWxpZGF0ZURhdGFBY2Nlc3MobnVsbCBhcyBhbnkpKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChzZWN1cml0eS52YWxpZGF0ZURhdGFBY2Nlc3ModW5kZWZpbmVkIGFzIGFueSkpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHNlY3VyaXR5LnZhbGlkYXRlRGF0YUFjY2Vzcyh7fSBhcyBhbnkpKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1PDqWN1cml0w6kgY3J5cHRvZ3JhcGhpcXVlJywgKCkgPT4ge1xuICAgIGl0KCd1dGlsaXNlIGRlcyBwYXJhbcOodHJlcyBjcnlwdG9ncmFwaGlxdWVzIHPDqWN1cmlzw6lzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgc2VjdXJpdHkuZW5jcnlwdFNlbnNpdGl2ZURhdGEoeyB0ZXN0OiAnZGF0YScgfSk7XG4gICAgICBcbiAgICAgIC8vIFbDqXJpZmllciBxdWUgbGVzIG3DqXRob2RlcyBjcnlwdG8gb250IMOpdMOpIGFwcGVsw6llcyBhdmVjIGxlcyBib25zIHBhcmFtw6h0cmVzXG4gICAgICBleHBlY3QobW9ja0NyeXB0b1N1YnRsZS5lbmNyeXB0KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3QobW9ja0NyeXB0b0dldFJhbmRvbVZhbHVlcykudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2fDqW7DqHJlIGRlcyBJVnMgYWzDqWF0b2lyZXMgdW5pcXVlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFNpbXVsZXIgcGx1c2lldXJzIGNoaWZmcmVtZW50c1xuICAgICAgbW9ja0NyeXB0b0dldFJhbmRvbVZhbHVlcy5tb2NrQ2xlYXIoKTtcbiAgICAgIGF3YWl0IHNlY3VyaXR5LmVuY3J5cHRTZW5zaXRpdmVEYXRhKHsgdGVzdDogMSB9KTtcbiAgICAgIGF3YWl0IHNlY3VyaXR5LmVuY3J5cHRTZW5zaXRpdmVEYXRhKHsgdGVzdDogMiB9KTtcbiAgICAgIGF3YWl0IHNlY3VyaXR5LmVuY3J5cHRTZW5zaXRpdmVEYXRhKHsgdGVzdDogMyB9KTtcbiAgICAgIFxuICAgICAgLy8gVsOpcmlmaWVyIHF1ZSBnZXRSYW5kb21WYWx1ZXMgYSDDqXTDqSBhcHBlbMOpIHBsdXNpZXVycyBmb2lzXG4gICAgICBleHBlY3QobW9ja0NyeXB0b0dldFJhbmRvbVZhbHVlcykudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KG1vY2tDcnlwdG9HZXRSYW5kb21WYWx1ZXMubW9jay5jYWxscy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMyk7XG4gICAgfSk7XG5cbiAgICBpdCgncmVmdXNlIGxlIGNoaWZmcmVtZW50IHNpIFdlYkNyeXB0byBlc3QgaW5kaXNwb25pYmxlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIGluc3RhbmNlIHdpdGhvdXQgY3J5cHRvXG4gICAgICBjb25zdCB0ZXN0U2VjdXJpdHkgPSBuZXcgU2VjdXJpdHlNYW5hZ2VyKHRydWUpO1xuICAgICAgXG4gICAgICAvLyBUZXN0IHdpbGwgZmFpbCBhdCB0aGUgY3J5cHRvIGNoZWNrIGxldmVsXG4gICAgICBhd2FpdCBleHBlY3QodGVzdFNlY3VyaXR5LmVuY3J5cHRTZW5zaXRpdmVEYXRhKHt9KSlcbiAgICAgICAgLnJlamVjdHNcbiAgICAgICAgLnRvVGhyb3coKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Byb3RlY3Rpb24gZGVzIGRvbm7DqWVzIHNlbnNpYmxlcycsICgpID0+IHtcbiAgICBpdCgnc3VwcHJpbWUgY29tcGzDqHRlbWVudCBsZXMgZG9ubsOpZXMgUElJIGxvcnMgZGUgbFxcJ2Fub255bWlzYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzZW5zaXRpdmVEYXRhID0ge1xuICAgICAgICBlbWFpbDogJ3VzZXJAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnSm9obiBEb2UnLFxuICAgICAgICBhZGRyZXNzOiAnMTIzIFNlY3JldCBTdCcsXG4gICAgICAgIHBob25lOiAnKzEyMzQ1Njc4OTAnLFxuICAgICAgICB1cmw6ICdodHRwczovL2JhbmsuZXhhbXBsZS5jb20vYWNjb3VudC8xMjM0NScsXG4gICAgICAgIHVzZXJJZDogJ3VzZXIxMjMnLFxuICAgICAgICBsZWdpdGltYXRlRGF0YTogJ2tlZXAgdGhpcydcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IGFub255bWl6ZWQgPSBhd2FpdCBzZWN1cml0eS5hbm9ueW1pemVGb3JTaGFyaW5nKHNlbnNpdGl2ZURhdGEpO1xuICAgICAgXG4gICAgICAvLyBEb25uw6llcyBzZW5zaWJsZXMgc3VwcHJpbcOpZXNcbiAgICAgIGV4cGVjdChhbm9ueW1pemVkLmVtYWlsKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgICBleHBlY3QoYW5vbnltaXplZC5uYW1lKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgICBleHBlY3QoYW5vbnltaXplZC5hZGRyZXNzKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgICBleHBlY3QoYW5vbnltaXplZC5waG9uZSkudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgXG4gICAgICAvLyBVUkwgYW5vbnltaXPDqWVcbiAgICAgIGV4cGVjdChhbm9ueW1pemVkLnVybCkudG9CZSgnYW5vbnltaXplZCcpO1xuICAgICAgXG4gICAgICAvLyBJRCBoYXNow6lcbiAgICAgIGV4cGVjdChhbm9ueW1pemVkLnVzZXJJZCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChhbm9ueW1pemVkLnVzZXJJZCkubm90LnRvQmUoJ3VzZXIxMjMnKTtcbiAgICAgIFxuICAgICAgLy8gRG9ubsOpZXMgbMOpZ2l0aW1lcyBjb25zZXJ2w6llc1xuICAgICAgZXhwZWN0KGFub255bWl6ZWQubGVnaXRpbWF0ZURhdGEpLnRvQmUoJ2tlZXAgdGhpcycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2fDqW7DqXJhbGlzZSBsZXMgdGltZXN0YW1wcyBwb3VyIMOpdml0ZXIgbGUgdHJhY2tpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgcHJlY2lzZVRpbWVzdGFtcCA9IG5vdzsgLy8gVGltZXN0YW1wIHByw6ljaXNcbiAgICAgIFxuICAgICAgY29uc3QgZGF0YSA9IHsgdGltZXN0YW1wOiBwcmVjaXNlVGltZXN0YW1wIH07XG4gICAgICBjb25zdCBhbm9ueW1pemVkID0gYXdhaXQgc2VjdXJpdHkuYW5vbnltaXplRm9yU2hhcmluZyhkYXRhKTtcbiAgICAgIFxuICAgICAgLy8gTGUgdGltZXN0YW1wIGRvaXQgw6p0cmUgYXJyb25kaSDDoCBsJ2hldXJlXG4gICAgICBjb25zdCBleHBlY3RlZFRpbWVzdGFtcCA9IE1hdGguZmxvb3IocHJlY2lzZVRpbWVzdGFtcCAvICg2MCAqIDYwICogMTAwMCkpICogKDYwICogNjAgKiAxMDAwKTtcbiAgICAgIGV4cGVjdChhbm9ueW1pemVkLnRpbWVzdGFtcCkudG9CZShleHBlY3RlZFRpbWVzdGFtcCk7XG4gICAgICBleHBlY3QoYW5vbnltaXplZC50aW1lc3RhbXApLm5vdC50b0JlKHByZWNpc2VUaW1lc3RhbXApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUsOpc2lzdGFuY2UgYXV4IGTDqWNoaWZmcmVtZW50cyBtYWx2ZWlsbGFudHMnLCAoKSA9PiB7XG4gICAgaXQoJ2fDqHJlIGdyYWNpZXVzZW1lbnQgbGVzIGRvbm7DqWVzIGNvcnJvbXB1ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb3JydXB0ZWREYXRhID0gW1xuICAgICAgICAnaW52YWxpZC1iYXNlNjQnLFxuICAgICAgICAnJyxcbiAgICAgICAgJ2NvcnJ1cHRlZC1kYXRhLXRoYXQtbG9va3MtdmFsaWQtYnV0LWlzbnQnLFxuICAgICAgICAnZXlKcGJuWmhiR2xrSWpvaWRHVnpkQ0o5JywgLy8gVmFsaWQgYmFzZTY0IGJ1dCBpbnZhbGlkIGVuY3J5cHRlZCBkYXRhXG4gICAgICBdO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGRhdGEgb2YgY29ycnVwdGVkRGF0YSkge1xuICAgICAgICBhd2FpdCBleHBlY3Qoc2VjdXJpdHkuZGVjcnlwdFNlbnNpdGl2ZURhdGEoZGF0YSkpXG4gICAgICAgICAgLnJlamVjdHNcbiAgICAgICAgICAudG9UaHJvdygnw4ljaGVjIGR1IGTDqWNoaWZmcmVtZW50IGRlcyBkb25uw6llcycpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3JlZnVzZSBsZXMgdHlwZXMgZGUgZG9ubsOpZXMgaW5jb3JyZWN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRJbnB1dHMgPSBbXG4gICAgICAgIDEyMyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB7fSxcbiAgICAgICAgW10sXG4gICAgICAgIFN5bWJvbCgndGVzdCcpXG4gICAgICBdO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGludmFsaWRJbnB1dHMpIHtcbiAgICAgICAgYXdhaXQgZXhwZWN0KHNlY3VyaXR5LmRlY3J5cHRTZW5zaXRpdmVEYXRhKGlucHV0IGFzIGFueSkpXG4gICAgICAgICAgLnJlamVjdHNcbiAgICAgICAgICAudG9UaHJvdygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJ2ZXJzaW9uIjozfQ==