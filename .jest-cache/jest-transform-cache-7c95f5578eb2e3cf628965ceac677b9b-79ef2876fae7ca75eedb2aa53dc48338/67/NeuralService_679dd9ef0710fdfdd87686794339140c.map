{"file":"/mnt/c/Users/m_oli/Projets/SYMBIONT/src/core/services/NeuralService.ts","mappings":"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","names":[],"sources":["/mnt/c/Users/m_oli/Projets/SYMBIONT/src/core/services/NeuralService.ts"],"sourcesContent":["/**\n * NeuralService - Interface simplifiée pour les opérations neurales\n * Part du refactoring d'OrganismCore selon l'architecture hexagonale\n */\n\nimport { INeuralMesh } from '../interfaces/INeuralMesh';\nimport { OrganismTraits } from '../../shared/types/organism';\n\nexport interface NeuralProcessingResult {\n  success: boolean;\n  adaptations: Partial<OrganismTraits>;\n  confidence: number;\n  processingTime: number;\n}\n\nexport interface NeuralPattern {\n  id: string;\n  type: 'behavioral' | 'environmental' | 'social';\n  data: any;\n  timestamp: number;\n  confidence: number;\n}\n\nexport class NeuralService {\n  private mesh: INeuralMesh;\n  private processingQueue: NeuralPattern[] = [];\n  private isProcessing = false;\n\n  constructor(mesh: INeuralMesh) {\n    this.mesh = mesh;\n  }\n\n  /**\n   * Traite un stimulus et retourne les adaptations suggérées\n   */\n  async processStimulus(stimulus: any, currentTraits: OrganismTraits): Promise<NeuralProcessingResult> {\n    const startTime = Date.now();\n    \n    try {\n      // Conversion du stimulus en pattern neural\n      const pattern = this.convertStimulusToPattern(stimulus);\n      \n      // Traitement par le réseau neural\n      const result = this.mesh.processPattern \n        ? await this.mesh.processPattern(pattern)\n        : {};\n      \n      // Conversion du résultat en adaptations de traits\n      const adaptations = this.convertResultToTraitAdaptations(result, currentTraits);\n      \n      const processingTime = Date.now() - startTime;\n      \n      return {\n        success: true,\n        adaptations,\n        confidence: result.confidence || 0.8,\n        processingTime\n      };\n    } catch (error) {\n      console.error('Erreur de traitement neural:', error);\n      \n      return {\n        success: false,\n        adaptations: {},\n        confidence: 0,\n        processingTime: Date.now() - startTime\n      };\n    }\n  }\n\n  /**\n   * Ajoute un pattern à la queue de traitement\n   */\n  queuePattern(pattern: NeuralPattern): void {\n    this.processingQueue.push(pattern);\n    \n    if (!this.isProcessing) {\n      this.processQueue();\n    }\n  }\n\n  /**\n   * Traite la queue de patterns en arrière-plan\n   */\n  private async processQueue(): Promise<void> {\n    if (this.isProcessing || this.processingQueue.length === 0) return;\n    \n    this.isProcessing = true;\n    \n    while (this.processingQueue.length > 0) {\n      const pattern = this.processingQueue.shift();\n      if (pattern) {\n        try {\n          if (this.mesh.learn) {\n            await this.mesh.learn(pattern.data);\n          }\n        } catch (error) {\n          console.error('Erreur apprentissage neural:', error);\n        }\n      }\n    }\n    \n    this.isProcessing = false;\n  }\n\n  /**\n   * Convertit un stimulus en pattern neural\n   */\n  private convertStimulusToPattern(stimulus: any): any {\n    // Simplification du stimulus pour le réseau neural\n    if (typeof stimulus === 'object' && stimulus !== null) {\n      return {\n        type: stimulus.type || 'unknown',\n        intensity: stimulus.intensity || 0.5,\n        context: stimulus.context || {},\n        timestamp: Date.now()\n      };\n    }\n    \n    return {\n      type: 'simple',\n      intensity: 0.5,\n      data: stimulus,\n      timestamp: Date.now()\n    };\n  }\n\n  /**\n   * Convertit le résultat neural en adaptations de traits\n   */\n  private convertResultToTraitAdaptations(result: any, currentTraits: OrganismTraits): Partial<OrganismTraits> {\n    const adaptations: Partial<OrganismTraits> = {};\n    \n    // Logique de conversion basée sur le type de résultat\n    if (result && typeof result === 'object') {\n      // Si le résultat contient des suggestions directes de traits\n      if (result.traitSuggestions) {\n        Object.entries(result.traitSuggestions).forEach(([trait, value]) => {\n          if (trait in currentTraits && typeof value === 'number') {\n            // Adaptation graduelle (maximum 10% de changement)\n            const currentValue = currentTraits[trait as keyof OrganismTraits];\n            const maxChange = 0.1;\n            const change = Math.max(-maxChange, Math.min(maxChange, value - currentValue));\n            adaptations[trait as keyof OrganismTraits] = currentValue + change;\n          }\n        });\n      }\n      \n      // Adaptations basées sur le type d'activité\n      if (result.activityType) {\n        switch (result.activityType) {\n          case 'exploration':\n            adaptations.curiosity = this.adjustTrait(currentTraits.curiosity, 0.05);\n            adaptations.adaptability = this.adjustTrait(currentTraits.adaptability, 0.03);\n            break;\n          case 'focus':\n            adaptations.focus = this.adjustTrait(currentTraits.focus, 0.05);\n            adaptations.memory = this.adjustTrait(currentTraits.memory, 0.02);\n            break;\n          case 'social':\n            adaptations.empathy = this.adjustTrait(currentTraits.empathy, 0.04);\n            adaptations.collaboration = this.adjustTrait(currentTraits.collaboration, 0.04);\n            break;\n          case 'creative':\n            adaptations.creativity = this.adjustTrait(currentTraits.creativity, 0.05);\n            adaptations.intuition = this.adjustTrait(currentTraits.intuition, 0.03);\n            break;\n        }\n      }\n    }\n    \n    return adaptations;\n  }\n\n  /**\n   * Ajuste un trait avec une limite de changement\n   */\n  private adjustTrait(currentValue: number, adjustment: number): number {\n    return Math.max(0, Math.min(1, currentValue + adjustment));\n  }\n\n  /**\n   * Effectue l'apprentissage à partir de données comportementales\n   */\n  async learn(behaviorData: any): Promise<boolean> {\n    try {\n      if (this.mesh.learn) {\n        await this.mesh.learn(behaviorData);\n      }\n      return true;\n    } catch (error) {\n      console.error('Erreur apprentissage:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Obtient les métriques de performance du réseau neural\n   */\n  getPerformanceMetrics(): any {\n    try {\n      return this.mesh.getPerformanceMetrics \n        ? this.mesh.getPerformanceMetrics()\n        : { nodeCount: 0, connectionCount: 0, neuralActivity: 0, connectionStrength: 0 };\n    } catch (error) {\n      console.error('Erreur métriques:', error);\n      return {\n        processingTime: 0,\n        accuracy: 0,\n        memoryUsage: 0\n      };\n    }\n  }\n\n  /**\n   * Sauvegarde l'état du réseau neural\n   */\n  saveState(): any {\n    try {\n      return this.mesh.saveState();\n    } catch (error) {\n      console.error('Erreur sauvegarde état neural:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Restaure l'état du réseau neural\n   */\n  loadState(state: any): boolean {\n    try {\n      this.mesh.loadState(state);\n      return true;\n    } catch (error) {\n      console.error('Erreur chargement état neural:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Réinitialise le réseau neural\n   */\n  reset(): void {\n    try {\n      this.mesh.reset();\n      this.processingQueue = [];\n      this.isProcessing = false;\n    } catch (error) {\n      console.error('Erreur reset neural:', error);\n    }\n  }\n\n  /**\n   * Nettoyage pour libérer les ressources\n   */\n  cleanup(): void {\n    this.processingQueue = [];\n    this.isProcessing = false;\n    \n    // Si le mesh a une méthode cleanup\n    if (typeof (this.mesh as any).cleanup === 'function') {\n      (this.mesh as any).cleanup();\n    }\n  }\n\n  /**\n   * Vérifie l'état de santé du service neural\n   */\n  healthCheck(): { healthy: boolean; issues: string[] } {\n    const issues: string[] = [];\n    \n    if (!this.mesh) {\n      issues.push('Réseau neural non initialisé');\n    }\n    \n    if (this.processingQueue.length > 1000) {\n      issues.push('Queue de traitement surchargée');\n    }\n    \n    try {\n      const metrics = this.getPerformanceMetrics();\n      if (metrics.processingTime > 1000) {\n        issues.push('Temps de traitement élevé');\n      }\n    } catch {\n      issues.push('Métriques non disponibles');\n    }\n    \n    return {\n      healthy: issues.length === 0,\n      issues\n    };\n  }\n\n  // =============================================================================\n  // MÉTHODES AJOUTÉES POUR COMPATIBILITÉ ORGANISMCORE\n  // =============================================================================\n\n  /**\n   * Initialize neural service\n   */\n  async initialize(): Promise<void> {\n    await this.mesh.initialize();\n  }\n\n  /**\n   * Suspend neural processing\n   */\n  async suspend(): Promise<void> {\n    await this.mesh.suspend();\n  }\n\n  /**\n   * Update neural processing with delta time\n   */\n  update(deltaTime: number): void {\n    // Process pending patterns based on delta time\n    const timeFactor = deltaTime / 16.67; // Normalize to 60fps\n    const patternsToProcess = Math.ceil(timeFactor);\n    \n    for (let i = 0; i < patternsToProcess && this.processingQueue.length > 0; i++) {\n      const pattern = this.processingQueue.shift();\n      if (pattern && this.mesh.learn) {\n        this.mesh.learn(pattern.data).catch(error => {\n          console.error('Neural processing error:', error);\n        });\n      }\n    }\n  }\n\n  /**\n   * Stimulate neural input\n   */\n  stimulate(inputId: string, value: number): void {\n    this.mesh.stimulate(inputId, value);\n  }\n\n  /**\n   * Get neural activity level\n   */\n  getNeuralActivity(): number {\n    return this.mesh.getNeuralActivity();\n  }\n}"],"version":3}