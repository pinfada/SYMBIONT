9797f57be9682bbacb88936774e3ef5e
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
jest.mock('../src/background/service-worker-adapter', () => ({
    swCryptoAPI: {
        subtle: mockCryptoSubtle,
        getRandomValues: mockCryptoGetRandomValues
    }
}));
// Simple test pour débugger le problème crypto
const mockCryptoSubtle = {
    generateKey: jest.fn().mockResolvedValue({
        type: 'secret',
        extractable: true,
        algorithm: { name: 'AES-GCM', length: 256 },
        usages: ['encrypt', 'decrypt']
    }),
    encrypt: jest.fn().mockImplementation(async (algorithm, key, data) => {
        console.log('encrypt called with:', { algorithm, key, dataLength: data.byteLength });
        const result = new ArrayBuffer(32);
        console.log('encrypt returning:', result);
        return result;
    }),
};
const mockCryptoGetRandomValues = jest.fn().mockImplementation((arr) => {
    console.log('getRandomValues called with array length:', arr.length);
    for (let i = 0; i < arr.length; i++) {
        arr[i] = i % 256;
    }
    console.log('getRandomValues returning:', arr);
    return arr;
});
const SecurityManager_1 = require("../src/background/SecurityManager");
describe('Debug Crypto', () => {
    it('should debug encryption process', async () => {
        const security = new SecurityManager_1.SecurityManager(true);
        security.encryptionKey = {
            type: 'secret',
            extractable: true,
            algorithm: { name: 'AES-GCM', length: 256 },
            usages: ['encrypt', 'decrypt']
        };
        console.log('Starting encryption test...');
        try {
            const result = await security.encryptSensitiveData({ test: 'data' });
            console.log('Success! Result:', result);
        }
        catch (error) {
            console.log('Error caught:', error);
        }
        console.log('getRandomValues call count:', mockCryptoGetRandomValues.mock.calls.length);
        console.log('encrypt call count:', mockCryptoSubtle.encrypt.mock.calls.length);
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL21udC9jL1VzZXJzL21fb2xpL1Byb2pldHMvU1lNQklPTlQvX190ZXN0c19fL2RlYnVnLWNyeXB0by50ZXN0LnRzIiwibWFwcGluZ3MiOiI7O0FBeUJBLElBQUksQ0FBQyxJQUFJLENBQUMsMENBQTBDLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztJQUMzRCxXQUFXLEVBQUU7UUFDWCxNQUFNLEVBQUUsZ0JBQWdCO1FBQ3hCLGVBQWUsRUFBRSx5QkFBeUI7S0FDM0M7Q0FDRixDQUFDLENBQUMsQ0FBQztBQTlCSiwrQ0FBK0M7QUFDL0MsTUFBTSxnQkFBZ0IsR0FBRztJQUN2QixXQUFXLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGlCQUFpQixDQUFDO1FBQ3ZDLElBQUksRUFBRSxRQUFRO1FBQ2QsV0FBVyxFQUFFLElBQUk7UUFDakIsU0FBUyxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFO1FBQzNDLE1BQU0sRUFBRSxDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUM7S0FDbEIsQ0FBQztJQUNmLE9BQU8sRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsa0JBQWtCLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLEVBQUU7UUFDbkUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxzQkFBc0IsRUFBRSxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDO1FBQ3JGLE1BQU0sTUFBTSxHQUFHLElBQUksV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ25DLE9BQU8sQ0FBQyxHQUFHLENBQUMsb0JBQW9CLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDMUMsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQyxDQUFDO0NBQ0gsQ0FBQztBQUVGLE1BQU0seUJBQXlCLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGtCQUFrQixDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUU7SUFDckUsT0FBTyxDQUFDLEdBQUcsQ0FBQywyQ0FBMkMsRUFBRSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDckUsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUNwQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztJQUNuQixDQUFDO0lBQ0QsT0FBTyxDQUFDLEdBQUcsQ0FBQyw0QkFBNEIsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUMvQyxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUMsQ0FBQyxDQUFDO0FBU0gsdUVBQW9FO0FBRXBFLFFBQVEsQ0FBQyxjQUFjLEVBQUUsR0FBRyxFQUFFO0lBQzVCLEVBQUUsQ0FBQyxpQ0FBaUMsRUFBRSxLQUFLLElBQUksRUFBRTtRQUMvQyxNQUFNLFFBQVEsR0FBRyxJQUFJLGlDQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDMUMsUUFBZ0IsQ0FBQyxhQUFhLEdBQUc7WUFDaEMsSUFBSSxFQUFFLFFBQVE7WUFDZCxXQUFXLEVBQUUsSUFBSTtZQUNqQixTQUFTLEVBQUUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUU7WUFDM0MsTUFBTSxFQUFFLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQztTQUNsQixDQUFDO1FBRWYsT0FBTyxDQUFDLEdBQUcsQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1FBRTNDLElBQUksQ0FBQztZQUNILE1BQU0sTUFBTSxHQUFHLE1BQU0sUUFBUSxDQUFDLG9CQUFvQixDQUFDLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7WUFDckUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxrQkFBa0IsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUMxQyxDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLE9BQU8sQ0FBQyxHQUFHLENBQUMsZUFBZSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3RDLENBQUM7UUFFRCxPQUFPLENBQUMsR0FBRyxDQUFDLDZCQUE2QixFQUFFLHlCQUF5QixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDeEYsT0FBTyxDQUFDLEdBQUcsQ0FBQyxxQkFBcUIsRUFBRSxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNqRixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9tbnQvYy9Vc2Vycy9tX29saS9Qcm9qZXRzL1NZTUJJT05UL19fdGVzdHNfXy9kZWJ1Zy1jcnlwdG8udGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTaW1wbGUgdGVzdCBwb3VyIGTDqWJ1Z2dlciBsZSBwcm9ibMOobWUgY3J5cHRvXG5jb25zdCBtb2NrQ3J5cHRvU3VidGxlID0ge1xuICBnZW5lcmF0ZUtleTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgXG4gICAgdHlwZTogJ3NlY3JldCcsIFxuICAgIGV4dHJhY3RhYmxlOiB0cnVlLCBcbiAgICBhbGdvcml0aG06IHsgbmFtZTogJ0FFUy1HQ00nLCBsZW5ndGg6IDI1NiB9LCBcbiAgICB1c2FnZXM6IFsnZW5jcnlwdCcsICdkZWNyeXB0J10gXG4gIH0gYXMgQ3J5cHRvS2V5KSxcbiAgZW5jcnlwdDogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoYWxnb3JpdGhtLCBrZXksIGRhdGEpID0+IHtcbiAgICBjb25zb2xlLmxvZygnZW5jcnlwdCBjYWxsZWQgd2l0aDonLCB7IGFsZ29yaXRobSwga2V5LCBkYXRhTGVuZ3RoOiBkYXRhLmJ5dGVMZW5ndGggfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5QnVmZmVyKDMyKTtcbiAgICBjb25zb2xlLmxvZygnZW5jcnlwdCByZXR1cm5pbmc6JywgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KSxcbn07XG5cbmNvbnN0IG1vY2tDcnlwdG9HZXRSYW5kb21WYWx1ZXMgPSBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKChhcnIpID0+IHtcbiAgY29uc29sZS5sb2coJ2dldFJhbmRvbVZhbHVlcyBjYWxsZWQgd2l0aCBhcnJheSBsZW5ndGg6JywgYXJyLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyW2ldID0gaSAlIDI1NjtcbiAgfVxuICBjb25zb2xlLmxvZygnZ2V0UmFuZG9tVmFsdWVzIHJldHVybmluZzonLCBhcnIpO1xuICByZXR1cm4gYXJyO1xufSk7XG5cbmplc3QubW9jaygnLi4vc3JjL2JhY2tncm91bmQvc2VydmljZS13b3JrZXItYWRhcHRlcicsICgpID0+ICh7XG4gIHN3Q3J5cHRvQVBJOiB7XG4gICAgc3VidGxlOiBtb2NrQ3J5cHRvU3VidGxlLFxuICAgIGdldFJhbmRvbVZhbHVlczogbW9ja0NyeXB0b0dldFJhbmRvbVZhbHVlc1xuICB9XG59KSk7XG5cbmltcG9ydCB7IFNlY3VyaXR5TWFuYWdlciB9IGZyb20gJy4uL3NyYy9iYWNrZ3JvdW5kL1NlY3VyaXR5TWFuYWdlcic7XG5cbmRlc2NyaWJlKCdEZWJ1ZyBDcnlwdG8nLCAoKSA9PiB7XG4gIGl0KCdzaG91bGQgZGVidWcgZW5jcnlwdGlvbiBwcm9jZXNzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHNlY3VyaXR5ID0gbmV3IFNlY3VyaXR5TWFuYWdlcih0cnVlKTtcbiAgICAoc2VjdXJpdHkgYXMgYW55KS5lbmNyeXB0aW9uS2V5ID0geyBcbiAgICAgIHR5cGU6ICdzZWNyZXQnLCBcbiAgICAgIGV4dHJhY3RhYmxlOiB0cnVlLCBcbiAgICAgIGFsZ29yaXRobTogeyBuYW1lOiAnQUVTLUdDTScsIGxlbmd0aDogMjU2IH0sIFxuICAgICAgdXNhZ2VzOiBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddIFxuICAgIH0gYXMgQ3J5cHRvS2V5O1xuXG4gICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIGVuY3J5cHRpb24gdGVzdC4uLicpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZWN1cml0eS5lbmNyeXB0U2Vuc2l0aXZlRGF0YSh7IHRlc3Q6ICdkYXRhJyB9KTtcbiAgICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzISBSZXN1bHQ6JywgcmVzdWx0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coJ0Vycm9yIGNhdWdodDonLCBlcnJvcik7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdnZXRSYW5kb21WYWx1ZXMgY2FsbCBjb3VudDonLCBtb2NrQ3J5cHRvR2V0UmFuZG9tVmFsdWVzLm1vY2suY2FsbHMubGVuZ3RoKTtcbiAgICBjb25zb2xlLmxvZygnZW5jcnlwdCBjYWxsIGNvdW50OicsIG1vY2tDcnlwdG9TdWJ0bGUuZW5jcnlwdC5tb2NrLmNhbGxzLmxlbmd0aCk7XG4gIH0pO1xufSk7Il0sInZlcnNpb24iOjN9