{"file":"/workspaces/SYMBIONT/__tests__/security/session-management.security.test.ts","mappings":"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","names":[],"sources":["/workspaces/SYMBIONT/__tests__/security/session-management.security.test.ts"],"sourcesContent":["/**\n * Tests de sécurité pour la gestion des sessions\n * Améliore la couverture de sécurité selon audit\n */\nimport { logger } from '@/shared/utils/secureLogger';\nimport { SecureRandom } from '@/shared/utils/secureRandom';\n\n// Mock session management classes\nclass SessionManager {\n  private sessions = new Map<string, SessionData>();\n  private readonly maxSessionAge = 24 * 60 * 60 * 1000; // 24 hours\n  private readonly maxSessions = 1000; // Prevent memory exhaustion\n\n  async createSession(userId: string): Promise<SessionToken> {\n    // Cleanup expired sessions first\n    this.cleanupExpiredSessions();\n    \n    // Prevent too many sessions\n    if (this.sessions.size >= this.maxSessions) {\n      throw new Error('Maximum sessions limit reached');\n    }\n\n    const sessionId = await this.generateSecureSessionId();\n    const token = await this.generateSessionToken(sessionId);\n    \n    const sessionData: SessionData = {\n      id: sessionId,\n      userId,\n      createdAt: Date.now(),\n      lastAccessedAt: Date.now(),\n      expiresAt: Date.now() + this.maxSessionAge,\n      isActive: true,\n      ipAddress: 'unknown', // Would be set from request\n      userAgent: 'unknown'  // Would be set from request\n    };\n\n    this.sessions.set(sessionId, sessionData);\n    \n    logger.info('Session created', { \n      sessionId: sessionId.substring(0, 8) + '...', // Partial logging for security\n      userId \n    }, 'session-management');\n\n    return { sessionId, token, expiresAt: sessionData.expiresAt };\n  }\n\n  async validateSession(sessionId: string, token: string): Promise<SessionData | null> {\n    const session = this.sessions.get(sessionId);\n    \n    if (!session) {\n      logger.warn('Session validation failed: session not found', { \n        sessionId: sessionId.substring(0, 8) + '...' \n      }, 'session-security');\n      return null;\n    }\n\n    // Check if session is expired\n    if (Date.now() > session.expiresAt || !session.isActive) {\n      this.destroySession(sessionId);\n      logger.warn('Session validation failed: session expired', { \n        sessionId: sessionId.substring(0, 8) + '...' \n      }, 'session-security');\n      return null;\n    }\n\n    // Validate token (in real implementation, this would use cryptographic verification)\n    const expectedToken = await this.generateSessionToken(sessionId);\n    if (token !== expectedToken) {\n      logger.error('Session validation failed: invalid token', { \n        sessionId: sessionId.substring(0, 8) + '...' \n      }, 'session-security');\n      return null;\n    }\n\n    // Update last accessed time\n    session.lastAccessedAt = Date.now();\n    \n    return session;\n  }\n\n  destroySession(sessionId: string): boolean {\n    const existed = this.sessions.has(sessionId);\n    this.sessions.delete(sessionId);\n    \n    if (existed) {\n      logger.info('Session destroyed', { \n        sessionId: sessionId.substring(0, 8) + '...' \n      }, 'session-management');\n    }\n    \n    return existed;\n  }\n\n  private async generateSecureSessionId(): Promise<string> {\n    // Generate cryptographically secure session ID\n    const bytes = new Uint8Array(32);\n    crypto.getRandomValues(bytes);\n    return Array.from(bytes, byte => byte.toString(16).padStart(2, '0')).join('');\n  }\n\n  private async generateSessionToken(sessionId: string): Promise<string> {\n    // In real implementation, this would be a cryptographically signed token\n    const encoder = new TextEncoder();\n    const data = encoder.encode(sessionId + Date.now().toString());\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n  }\n\n  private cleanupExpiredSessions(): void {\n    const now = Date.now();\n    const expiredSessions = [];\n    \n    for (const [sessionId, session] of this.sessions.entries()) {\n      if (now > session.expiresAt || !session.isActive) {\n        expiredSessions.push(sessionId);\n      }\n    }\n    \n    expiredSessions.forEach(sessionId => {\n      this.sessions.delete(sessionId);\n    });\n    \n    if (expiredSessions.length > 0) {\n      logger.info('Cleaned up expired sessions', { \n        count: expiredSessions.length \n      }, 'session-management');\n    }\n  }\n\n  getActiveSessionCount(): number {\n    this.cleanupExpiredSessions();\n    return this.sessions.size;\n  }\n}\n\ninterface SessionData {\n  id: string;\n  userId: string;\n  createdAt: number;\n  lastAccessedAt: number;\n  expiresAt: number;\n  isActive: boolean;\n  ipAddress: string;\n  userAgent: string;\n}\n\ninterface SessionToken {\n  sessionId: string;\n  token: string;\n  expiresAt: number;\n}\n\ndescribe('Session Management Security Tests', () => {\n  let sessionManager: SessionManager;\n\n  beforeEach(() => {\n    sessionManager = new SessionManager();\n  });\n\n  describe('Session Creation Security', () => {\n    it('should create sessions with cryptographically secure IDs', async () => {\n      const session1 = await sessionManager.createSession('user1');\n      const session2 = await sessionManager.createSession('user1');\n      \n      // Session IDs should be unique\n      expect(session1.sessionId).not.toBe(session2.sessionId);\n      \n      // Session IDs should be long enough (256 bits = 64 hex chars)\n      expect(session1.sessionId.length).toBe(64);\n      expect(session2.sessionId.length).toBe(64);\n      \n      // Session IDs should be hex strings\n      expect(session1.sessionId).toMatch(/^[a-f0-9]{64}$/);\n      expect(session2.sessionId).toMatch(/^[a-f0-9]{64}$/);\n    });\n\n    it('should set proper session expiration times', async () => {\n      const beforeCreation = Date.now();\n      const session = await sessionManager.createSession('user1');\n      const afterCreation = Date.now();\n      \n      // Session should expire in approximately 24 hours\n      const expectedExpiration = beforeCreation + 24 * 60 * 60 * 1000;\n      const maxExpiration = afterCreation + 24 * 60 * 60 * 1000;\n      \n      expect(session.expiresAt).toBeGreaterThanOrEqual(expectedExpiration);\n      expect(session.expiresAt).toBeLessThanOrEqual(maxExpiration);\n    });\n\n    it('should prevent session fixation attacks', async () => {\n      // Create multiple sessions for the same user\n      const sessions = await Promise.all([\n        sessionManager.createSession('user1'),\n        sessionManager.createSession('user1'),\n        sessionManager.createSession('user1')\n      ]);\n      \n      // Each session should have a unique ID\n      const sessionIds = sessions.map(s => s.sessionId);\n      const uniqueIds = new Set(sessionIds);\n      expect(uniqueIds.size).toBe(sessions.length);\n    });\n\n    it('should limit the number of concurrent sessions', async () => {\n      // This test simulates preventing memory exhaustion attacks\n      const maxSessions = 1000;\n      const sessionPromises = [];\n      \n      // Try to create slightly more than the maximum allowed sessions\n      for (let i = 0; i < maxSessions + 10; i++) {\n        sessionPromises.push(\n          sessionManager.createSession(`user${i}`).catch(() => null)\n        );\n      }\n      \n      const results = await Promise.all(sessionPromises);\n      const successfulSessions = results.filter(Boolean);\n      \n      // Should not exceed the maximum limit\n      expect(successfulSessions.length).toBeLessThanOrEqual(maxSessions);\n    }, 10000); // Increase timeout for this test\n  });\n\n  describe('Session Validation Security', () => {\n    it('should validate legitimate sessions correctly', async () => {\n      const session = await sessionManager.createSession('user1');\n      \n      const validatedSession = await sessionManager.validateSession(\n        session.sessionId, \n        session.token\n      );\n      \n      expect(validatedSession).toBeTruthy();\n      expect(validatedSession?.userId).toBe('user1');\n      expect(validatedSession?.isActive).toBe(true);\n    });\n\n    it('should reject invalid session IDs', async () => {\n      const maliciousSessionIds = [\n        'invalid-session-id',\n        '../../../etc/passwd',\n        '<script>alert(\"xss\")</script>',\n        'null',\n        '',\n        'a'.repeat(1000), // Too long\n        '0'.repeat(64), // Valid length but non-existent\n        'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' // Invalid hex\n      ];\n      \n      for (const sessionId of maliciousSessionIds) {\n        const result = await sessionManager.validateSession(sessionId, 'any-token');\n        expect(result).toBeNull();\n      }\n    });\n\n    it('should reject tampered tokens', async () => {\n      const session = await sessionManager.createSession('user1');\n      \n      const tamperedTokens = [\n        session.token + 'x', // Appended character\n        session.token.slice(0, -1), // Removed character\n        session.token.replace('a', 'b'), // Changed character\n        'malicious-token',\n        '',\n        null as any,\n        undefined as any\n      ];\n      \n      for (const token of tamperedTokens) {\n        const result = await sessionManager.validateSession(session.sessionId, token);\n        expect(result).toBeNull();\n      }\n    });\n\n    it('should handle expired sessions securely', async () => {\n      const session = await sessionManager.createSession('user1');\n      \n      // Mock expired session by manually setting expiration time in the past\n      const sessionData = await sessionManager.validateSession(session.sessionId, session.token);\n      if (sessionData) {\n        sessionData.expiresAt = Date.now() - 1000; // 1 second ago\n      }\n      \n      // Try to validate the expired session\n      const result = await sessionManager.validateSession(session.sessionId, session.token);\n      expect(result).toBeNull();\n      \n      // Session should be automatically cleaned up\n      const activeCount = sessionManager.getActiveSessionCount();\n      expect(activeCount).toBe(0);\n    });\n  });\n\n  describe('Session Destruction Security', () => {\n    it('should securely destroy sessions', async () => {\n      const session = await sessionManager.createSession('user1');\n      \n      // Verify session exists\n      let validatedSession = await sessionManager.validateSession(session.sessionId, session.token);\n      expect(validatedSession).toBeTruthy();\n      \n      // Destroy session\n      const destroyed = sessionManager.destroySession(session.sessionId);\n      expect(destroyed).toBe(true);\n      \n      // Verify session no longer exists\n      validatedSession = await sessionManager.validateSession(session.sessionId, session.token);\n      expect(validatedSession).toBeNull();\n    });\n\n    it('should handle double destruction safely', async () => {\n      const session = await sessionManager.createSession('user1');\n      \n      // Destroy session twice\n      const firstDestroy = sessionManager.destroySession(session.sessionId);\n      const secondDestroy = sessionManager.destroySession(session.sessionId);\n      \n      expect(firstDestroy).toBe(true);\n      expect(secondDestroy).toBe(false);\n    });\n\n    it('should clean up expired sessions automatically', async () => {\n      // Create multiple sessions\n      const sessions = await Promise.all([\n        sessionManager.createSession('user1'),\n        sessionManager.createSession('user2'),\n        sessionManager.createSession('user3')\n      ]);\n      \n      expect(sessionManager.getActiveSessionCount()).toBe(3);\n      \n      // Mock all sessions as expired\n      for (const session of sessions) {\n        const sessionData = await sessionManager.validateSession(session.sessionId, session.token);\n        if (sessionData) {\n          sessionData.expiresAt = Date.now() - 1000;\n        }\n      }\n      \n      // Trigger cleanup by calling getActiveSessionCount\n      const activeCount = sessionManager.getActiveSessionCount();\n      expect(activeCount).toBe(0);\n    });\n  });\n\n  describe('Session Hijacking Prevention', () => {\n    it('should detect session ID enumeration attempts', async () => {\n      const session = await sessionManager.createSession('user1');\n      \n      // Simulate session ID enumeration\n      const enumerationAttempts = [\n        session.sessionId.replace(/.$/, '0'),\n        session.sessionId.replace(/.$/, '1'),\n        session.sessionId.replace(/.$/, '2'),\n        session.sessionId.replace(/.$/, 'f'),\n        session.sessionId.slice(0, -1) + 'x'\n      ];\n      \n      let validationAttempts = 0;\n      for (const attemptId of enumerationAttempts) {\n        const result = await sessionManager.validateSession(attemptId, 'any-token');\n        validationAttempts++;\n        expect(result).toBeNull();\n      }\n      \n      expect(validationAttempts).toBe(enumerationAttempts.length);\n    });\n\n    it('should use secure random number generation', async () => {\n      // Test that session IDs use sufficient entropy\n      const sessions = await Promise.all(\n        Array.from({ length: 100 }, (_, i) => \n          sessionManager.createSession(`user${i}`)\n        )\n      );\n      \n      const sessionIds = sessions.map(s => s.sessionId);\n      \n      // Test entropy: no two session IDs should be similar\n      for (let i = 0; i < sessionIds.length; i++) {\n        for (let j = i + 1; j < sessionIds.length; j++) {\n          // Calculate Hamming distance (different characters)\n          let differences = 0;\n          for (let k = 0; k < Math.min(sessionIds[i].length, sessionIds[j].length); k++) {\n            if (sessionIds[i][k] !== sessionIds[j][k]) {\n              differences++;\n            }\n          }\n          \n          // At least 50% of characters should be different (good entropy)\n          const minDifferences = Math.floor(sessionIds[i].length * 0.5);\n          expect(differences).toBeGreaterThan(minDifferences);\n        }\n      }\n    }, 15000); // Increased timeout for this test\n  });\n\n  describe('Memory Security', () => {\n    it('should not leak sensitive data in memory', async () => {\n      const session = await sessionManager.createSession('user1');\n      \n      // Destroy the session\n      sessionManager.destroySession(session.sessionId);\n      \n      // The session data should not be accessible\n      const result = await sessionManager.validateSession(session.sessionId, session.token);\n      expect(result).toBeNull();\n    });\n\n    it('should handle memory pressure gracefully', async () => {\n      // Create many sessions to test memory management\n      const sessionPromises = Array.from({ length: 500 }, (_, i) => \n        sessionManager.createSession(`user${i}`)\n      );\n      \n      const sessions = await Promise.all(sessionPromises);\n      expect(sessions.length).toBe(500);\n      \n      // All sessions should be valid initially\n      const initialCount = sessionManager.getActiveSessionCount();\n      expect(initialCount).toBeLessThanOrEqual(500);\n    }, 10000);\n  });\n\n  describe('Logging Security', () => {\n    it('should log security events without exposing sensitive data', async () => {\n      const session = await sessionManager.createSession('user1');\n      \n      // Mock logger to capture logs\n      const logSpy = jest.spyOn(logger, 'warn');\n      \n      // Attempt invalid session validation\n      await sessionManager.validateSession('invalid-session', 'invalid-token');\n      \n      // Verify that sensitive data is not logged\n      expect(logSpy).toHaveBeenCalled();\n      const logCall = logSpy.mock.calls.find(call => \n        call[0].includes('Session validation failed')\n      );\n      \n      if (logCall) {\n        const logMessage = JSON.stringify(logCall);\n        expect(logMessage).not.toContain(session.token);\n        expect(logMessage).not.toContain(session.sessionId); // Full session ID should not be logged\n      }\n      \n      logSpy.mockRestore();\n    });\n  });\n});"],"version":3}